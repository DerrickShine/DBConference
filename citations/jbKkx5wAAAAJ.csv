Accelerating CUDA graph algorithms at maximum warp,Sungpack Hong; Sang Kyun Kim; Tayo Oguntebi; Kunle Olukotun,Abstract Graphs are powerful data representations favored in many computational domains.Modern GPUs have recently shown promising results in accelerating computationallychallenging graph problems but their performance suffered heavily when the graph structureis highly irregular; as most real-world graphs tend to be. In this study; we first observe thatthe poor performance is caused by work imbalance and is an artifact of a discrepancybetween the GPU programming model and the underlying GPU architecture. We thenpropose a novel virtual warp-centric programming method that exposes the traits ofunderlying GPU architectures to users. Our method significantly improves the performanceof applications with heavily imbalanced workloads; and enables trade-offs betweenworkload imbalance and ALU underutilization for fine-tuning the performance. Our …,ACM SIGPLAN Notices,2011,293
Efficient parallel graph exploration on multi-core CPU and GPU,Sungpack Hong; Tayo Oguntebi; Kunle Olukotun,Graphs are a fundamental data representation that has been used extensively in variousdomains. In graph-based applications; a systematic exploration of the graph such as abreadth-first search (BFS) often serves as a key component in the processing of theirmassive data sets. In this paper; we present a new method for implementing the parallel BFSalgorithm on multi-core CPUs which exploits a fundamental property of randomly shapedreal-world graph instances. By utilizing memory bandwidth more efficiently; our methodshows improved performance over the current state-of-the-art implementation and increasesits advantage as the size of the graph increases. We then propose a hybrid method which;for each level of the BFS algorithm; dynamically chooses the best implementation from: asequential execution; two different methods of multicore execution; and a GPU execution …,Parallel Architectures and Compilation Techniques (PACT); 2011 International Conference on,2011,245
Green-Marl: A DSL for Easy and Efficient Graph Analysis,Sungpack Hong; Hassan Chafi; Eric Sedlar; Kunle Olukotun,Abstract The increasing importance of graph-data based applications is fueling the need forhighly efficient and parallel implementations of graph analysis software. In this paper wedescribe Green-Marl; a domain-specific language (DSL) whose high level languageconstructs allow developers to describe their graph analysis algorithms intuitively; butexpose the data-level parallelism inherent in the algorithms. We also present our Green-Marl compiler which translates high-level algorithmic description written in Green-Marl intoan efficient C++ implementation by exploiting this exposed data-level parallelism.Furthermore; our Green-Marl compiler applies a set of optimizations that take advantage ofthe high-level semantic knowledge encoded in the Green-Marl DSL. We demonstrate thatgraph analysis algorithms can be written very intuitively with Green-Marl through some …,ASPLOS,2012,215
A scalable processing-in-memory accelerator for parallel graph processing,Junwhan Ahn; Sungpack Hong; Sungjoo Yoo; Onur Mutlu; Kiyoung Choi,Abstract The explosion of digital data and the ever-growing need for fast data analysis havemade in-memory big-data processing in computer systems increasingly important. Inparticular; large-scale graph processing is gaining attention due to its broad applicabilityfrom social science to machine learning. However; scalable hardware design that canefficiently process large graphs in main memory is still an open problem. Ideally; cost-effective and scalable graph processing systems can be realized by building a systemwhose performance increases proportionally with the sizes of graphs that can be stored inthe system; which is extremely challenging in conventional systems due to severe memorybandwidth limitations. In this work; we argue that the conventional concept of processing-in-memory (PIM) can be a viable solution to achieve such an objective. The key modern …,ACM SIGARCH Computer Architecture News,2016,177
Eigenbench: A simple exploration tool for orthogonal TM characteristics,Sungpack Hong; Tayo Oguntebi; Jared Casper; Nathan Bronson; Christos Kozyrakis; Kunle Olukotun,There are a significant number of Transactional Memory (TM) proposals; varying in almostall aspects of the design space. Although several transactional benchmarks have beensuggested; a simple; yet thorough; evaluation framework is still needed to completelycharacterize a TM system and allow for comparison among the various proposals.Unfortunately; TM system evaluation is difficult because the application characteristics whichaffect performance are often difficult to isolate from each other. We propose a set oforthogonal application characteristics that form a basis for transactional behavior and areuseful in fully understanding the performance of a TM system. In this paper; we presentEigenBench; a lightweight yet powerful microbenchmark for fully evaluating a transactionalmemory system. We show that EigenBench is useful for thoroughly exploring the …,Workload Characterization (IISWC); 2010 IEEE International Symposium on,2010,67
On fast parallel detection of strongly connected components (SCC) in small-world graphs,Sungpack Hong; Nicole C Rodia; Kunle Olukotun,Detecting strongly connected components (SCCs) in a directed graph is a fundamentalgraph analysis algorithm that is used in many science and engineering domains. Traditionalapproaches in parallel SCC detection; however; show limited performance and poor scalingbehavior when applied to large real-world graph instances. In this paper; we investigate theshortcomings of the conventional approach and propose a series of extensions that considerthe fundamental properties of real-world graphs; eg the small-world property. Our scalableimplementation offers excellent performance on diverse; small-world graphs resulting in a5.01× to 29.41× parallel speedup over the optimal sequential algorithm with 16 cores and 32hardware threads.,High Performance Computing; Networking; Storage and Analysis (SC); 2013 International Conference for,2013,57
Bus-invert coding for low-power I/O-a decomposition approach,Sungpack Hong; Unni Narayanan; Ki-Seok Chung; Taewhan Kim,This paper proposes a new bus-invert coding scheme for reducing the number of bustransitions. Unlike the previous schemes in which the entire bus lines or one subset of thebus fines are considered for bus-invert coding; in the proposed scheme the bus lines arepartitioned and each partitioned group is considered independently for bus-invert coding tomaximize the effectiveness of reducing the total number of bus transitions. Experimentalresults show that the decomposed bus-invert coding scheme reduces the total number ofbus transitions by 47.2% and 11.9% on average than those of the conventional and thepartial bus-invert coding schemes; respectively.,Circuits and Systems; 2000. Proceedings of the 43rd IEEE Midwest Symposium on,2000,42
Simplifying scalable graph processing with a domain-specific language,Sungpack Hong; Semih Salihoglu; Jennifer Widom; Kunle Olukotun,Abstract Large-scale graph processing; with its massive data sets; requires distributedprocessing. However; conventional frameworks for distributed graph processing; such asPregel; use non-traditional programming models that are well-suited for parallelism andscalability but inconvenient for implementing non-trivial graph algorithms. In this paper; weuse Green-Marl; a Domain-Specific Language for graph analysis; to intuitively describegraph algorithms and extend its compiler to generate equivalent Pregel implementations.Using the semantic information captured by Green-Marl; the compiler applies a set oftransformation rules that convert imperative graph algorithms into Pregel's programmingmodel. Our experiments show that the Pregel programs generated by the Green-Marlcompiler perform similarly to manually coded Pregel implementations of the same …,Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization,2014,38
PGX. D: a fast distributed graph processing engine,Sungpack Hong; Siegfried Depner; Thomas Manhardt; Jan Van Der Lugt; Merijn Verstraaten; Hassan Chafi,Abstract Graph analysis is a powerful method in data analysis. Although several frameworkshave been proposed for processing large graph instances in distributed environments; theirperformance is much lower than using efficient single-machine implementations providedwith enough memory. In this paper; we present a fast distributed graph processing system;namely PGX. D. We show that PGX. D outperforms other distributed graph systems likeGraphLab significantly (3x--90x). Furthermore; PGX. D on 4 to 16 machines is also fasterthan an implementation optimized for single-machine execution. Using a fast cooperativecontext-switching mechanism; we implement PGX. D as a low-overhead; bandwidth-efficientcommunication framework that supports remote data-pulling patterns. Moreover; PGX. Dachieves large traffic reduction and good workload balance by applying selective ghost …,Proceedings of the International Conference for High Performance Computing; Networking; Storage and Analysis,2015,34
Creation and utilization of a virtual platform for embedded software optimization:: an industrial case study,Sungpack Hong; Sungjoo Yoo; Sheayun Lee; Sangwoo Lee; Hye Jeong Nam; Bum-Seok Yoo; Jaehyung Hwang; Donghyun Song; Janghwan Kim; Jeongeun Kim; HoonSang Jin; Kyu-Myung Choi; Jeong-Taek Kong; SooKwan Eo,Abstract Virtual platform (ViP); or ESL (Electronic System Level) simulation model; is one ofthe most widely renowned system level design techniques. In this paper; we present a casestudy of creating and applying the ViP in the development of a new hard disk system calledHybrid-HDD that is one of the main features in the Windows VISTA (R). First; we summarizehow we developed the ViP including the levels of timing accuracy of models; automaticgeneration of models from RTL code; external subsystem models; etc. Then; we explain howwe exploited the ViP in software optimization. Compared with the conventional flow ofsoftware development; eg based on the real board; the ViP gives a better profiling capabilitythereby allowing designers to find more chances of code optimization. Based on thesimulation and analysis with the ViP; the software optimization could improve system …,Proceedings of the 4th international conference on Hardware/software codesign and system synthesis,2006,32
Hardware acceleration of transactional memory on commodity systems,Jared Casper; Tayo Oguntebi; Sungpack Hong; Nathan G Bronson; Christos Kozyrakis; Kunle Olukotun,Abstract The adoption of transactional memory is hindered by the high overhead of softwaretransactional memory and the intrusive design changes required by previously proposed TMhardware. We propose that hardware to accelerate software transactional memory (STM)can reside outside an unmodified commodity processor core; thereby substantially reducingimplementation costs. This paper introduces Transactional Memory Acceleration usingCommodity Cores (TMACC); a hardware-accelerated TM system that does not modify theprocessor; caches; or coherence protocol. We present a complete hardware implementationof TMACC using a rapid prototyping platform. Using this hardware; we implement twounique conflict detection schemes which are accelerated using Bloom filters on an FPGA.These schemes employ novel techniques for tolerating the latency of fine-grained …,ACM SIGPLAN Notices,2011,30
Taming subgraph isomorphism for RDF query processing,Jinha Kim; Hyungyu Shin; Wook-Shin Han; Sungpack Hong; Hassan Chafi,Abstract RDF data are used to model knowledge in various areas such as life sciences;Semantic Web; bioinformatics; and social graphs. The size of real RDF data reaches billionsof triples. This calls for a framework for efficiently processing RDF data. The core function ofprocessing RDF data is subgraph pattern matching. There have been two completelydifferent directions for supporting efficient subgraph pattern matching. One direction is todevelop specialized RDF query processing engines exploiting the properties of RDF data forthe last decade; while the other direction is to develop efficient subgraph isomorphismalgorithms for general; labeled graphs for over 30 years. Although both directions have asimilar goal (ie; finding subgraphs in data graphs for a given query graph); they have beenindependently researched without clear reason. We argue that a subgraph isomorphism …,Proceedings of the VLDB Endowment,2015,24
PGQL: a property graph query language,Oskar van Rest; Sungpack Hong; Jinha Kim; Xuming Meng; Hassan Chafi,Abstract Graph-based approaches to data analysis have become more widespread; whichhas given need for a query language for graphs. Such a graph query language needs notonly SQL-like functionality for querying structured data; but also intrinsic support for typicalgraph-style applications: reachability analysis; path finding and graph construction. Wepropose a new query language for the popular Property Graph (PG) data model: theProperty Graph Query Language (PGQL). PGQL is based on the paradigm of graph patternmatching; closely follows syntactic structures of SQL; and provides regular path queries withconditions on labels and properties to allow for reachability and path finding queries.Besides intrinsic vertex; edge and path types; PGQL also has the graph as intrinsic type andallows for graph construction and query composition.,Proceedings of the Fourth International Workshop on Graph Data Management Experiences and Systems,2016,22
Bus optimization for low-power data path synthesis based on network flow method,Sungpack Hong; Taewhan Kim,Abstract Sub-micron feature sizes have resulted in a considerable portion of power to bedissipated on the buses; causing an increased attention on savings for power at thebehavioral level and RT level of design. This paper addresses the problem of minimizingpower dissipated in switching of the buses in data path synthesis. Unlike the previousapproaches in which minimization of the power consumed in buses has not beenconsidered until operation scheduling is completed; our approach integrates the bus bindingproblem into scheduling to exploit the impact of scheduling on reduction of power dissipatedon the buses more fully and effectively. We accomplish this by formulating the problem into aflow problem in a network; and devising an efficient algorithm which iteratively findsmaximum flow of minimum cost solutions in the network. Experimental results on a …,Proceedings of the 2000 IEEE/ACM international conference on Computer-aided design,2000,22
Graph analysis: do we have to reinvent the wheel?,Adam Welc; Raghavan Raman; Zhe Wu; Sungpack Hong; Hassan Chafi; Jay Banerjee,Abstract The problem of efficiently analyzing graphs of various shapes and sizes has beenrecently enjoying an increased level of attention both in the academia and in the industry.This trend prompted creation of specialized graph databases that have been rapidly gainingpopularity of late. In this paper we argue that there exist alternatives to graph databases;providing competitive or superior performance; that do not require replacement of the entireexisting storage infrastructure by the companies wishing to deploy them.,First International Workshop on Graph Data Management Experiences and Systems,2013,21
Dynamic voltage scaling of supply and body bias exploiting software runtime distribution,Sungpack Hong; Sungjoo Yoo; Byeong Bin; Kyu-Myung Choi; Soo-Kwan Eo; Taehwan Kim,Abstract This paper presents a method of dynamic voltage scaling (DVS) that tackles bothswitching and leakage power with combined V dd/V bs scaling and gives minimum averageenergy consumption exploiting the runtime distribution of software execution. We present amathematical formulation of the DVS problem and an efficient numerical solution.Experimental results show that the presented method shows up to 44% further reduction inenergy consumption compared with existing methods. Especially; when the leakage powerconsumption is significant; ie when temperature is high; the presented method is proven tobe the most effective.,Proceedings of the conference on Design; automation and test in Europe,2008,20
Memory system having nonvolatile and buffer memories; and reading method thereof,*,Disclosed is a method for reading data in a memory system including a buffer memory and anonvolatile memory; the method being comprised of: determining whether an input addressin a read request is allocated to the buffer memory; determining whether a size of requesteddata is larger than a reference unless the input address is allocated to the buffer memory;and conducting a prefetch reading operation from the nonvolatile memory if the requesteddata size is larger than the reference.,*,2011,18
FARM: A prototyping environment for tightly-coupled; heterogeneous architectures,Tayo Oguntebi; Sungpack Hong; Jared Casper; Nathan Bronson; Christos Kozyrakis; Kunle Olukotun,Computer architectures are increasingly turning to parallelism and heterogeneity assolutions for boosting performance in the face of power constraints. As this trend continues;the challenges of simulating and evaluating these architectures have grown. Hardwareprototypes provide deeper insight into these systems when compared to simulators; but aretraditionally more difficult and costly to build. We present the Flexible Architecture ResearchMachine (FARM); a hardware prototyping system based on an FPGA coherently connectedto a multiprocessor system. FARM substantially reduces the difficulty and cost of buildinghardware prototypes by providing a ready-made framework for communicating with acustom design on the FPGA. FARM ensures efficient; low-latency communication with theFPGA via a variety of mechanisms; allowing a wide range of applications to effectively …,Field-Programmable Custom Computing Machines (FCCM); 2010 18th IEEE Annual International Symposium on,2010,18
Runtime distribution-aware dynamic voltage scaling,Sungpack Hong; Sungjoo Yoo; Hoonsang Jin; Kyu-Myung Choi; Jeong-Taek Kong; Soo-Kwan Eo,Abstract We propose a new intra-task dynamic voltage scaling (DVS) method to capture animportant fact of'software runtime distribution'and integrate it into DVS effectively.Specifically; the proposed method finds performance levels; for a given software runtimedistribution; ie statistical profiling of execution cycles (neither the execution cycle of worst-case execution path nor the worst-case execution cycles of basic blocks); which leads toa'minimal energy consumption while satisfying the given deadline constraints. Experimentalresults report that the proposed method gives 19.2%~ 33.3% further energy reductioncompared with the best-known methods for two industrial multimedia software programs; H.264 decoder and MPEG4 decoder.,Proceedings of the 2006 IEEE/ACM international conference on Computer-aided design,2006,18
Decomposition of bus-invert coding for low-power I/O,Sungpack Hong; Taewhan Kim; Unni Narayanan; Ki-Seok Chung,This paper proposes a new bus-invert coding scheme for reducing the number of bustransitions. Unlike the previous schemes in which the entire bus lines or one subset of thebus lines are considered for bus-invert coding; in the proposed scheme; the bus lines arepartitioned and each partitioned group is considered independently for bus-invert coding tomaximize the effectiveness of reducing the total number of bus transitions. Experimentalresults show that the decomposed bus-invert coding scheme reduces the total number ofbus transitions by 47.2% and 11.9% on average than those of the conventional and thepartial bus-invert coding schemes respectively.,Journal of Circuits; Systems; and Computers,2000,17
Pgx. iso: parallel and efficient in-memory engine for subgraph isomorphism,Raghavan Raman; Oskar van Rest; Sungpack Hong; Zhe Wu; Hassan Chafi; Jay Banerjee,Abstract Subgraph isomorphism; or finding matching patterns in a graph; is a classic graphproblem that has many practical use cases. There are even commercialized solutions for thisproblem such as RDF databases with their support for SPARQL queries. In this paper; wepresent an efficient; parallel in-memory solution to this problem. Our solution exploitsefficient data representations as well as algorithmic extensions; both tailored for parallel; in-memory processing. Moreover; when processing RDF data; we reduce the problem size byconverting certain nodes and edges into properties. We also propose a new graph querylanguage where such a conversion can be encoded. Our evaluation shows that our solutioncan achieve significant performance boost over an existing secondary storage based RDFdatabase.,Proceedings of Workshop on GRAph Data management Experiences and Systems,2014,12
Fast in-memory triangle listing for large real-world graphs,Martin Sevenich; Sungpack Hong; Adam Welc; Hassan Chafi,Abstract Triangle listing; or identifying all the triangles in an undirected graph; is a veryimportant graph problem that serves as a building block of many other graph algorithms. Thecompute-intensive nature of the problem; however; necessitates an efficient method to solvethis problem; especially for large real-world graphs. In this paper we propose a fast andprecise in-memory solution for the triangle listing problem. Our solution includes fastcommon neighborhoods finding methods that consider power law degree distribution of real-word graphs. We prove how theoretic lower bound can be achieved by sorting the nodes inthe graph by their degree and applying pruning. We explain how our techniques can beapplied automatically by an optimizing DSL compiler. Our experiments show that hundredsof billions of triangles in a five billion edge graph can be enumerated in about a minute …,Proceedings of the 8th Workshop on Social Network Mining and Analysis,2014,11
Dynamic voltage scaling method of CPU using workload estimator and computer readable medium storing the method,*,A method for scaling a dynamic voltage of a CPU is achieved by setting a voltage settingpoint for each of a plurality of code segments of a program; and profiling workload bymeasuring a workload variation of each of the code segments based on data that changeswhenever measured; selecting a plurality of combinations; each having a plurality of voltagesetting points; and calculating workload estimators corresponding to the voltage settingpoints of each of the selected combinations based on the workload variation measured inthe workload profiling operation; selecting an optimal combination that consumes a leastenergy of the CPU based on the workload estimators; and determining whether a real timeconstraint is satisfied when an operating voltage is set based on the workload estimatorcorresponding to each of the voltage setting points of the optimal combination during …,*,2010,10
Early experiences in using a domain-specific language for large-scale graph analysis,Sungpack Hong; Jan Van Der Lugt; Adam Welc; Raghavan Raman; Hassan Chafi,Abstract Large-scale graph analysis has recently been drawing lots of attention from bothindustry and academia. Although there are already several frameworks designed forscalable graph analysis; eg Giraph [1]; all these frameworks adopt non-traditionalprogramming models and APIs. This can significantly lower the productivity of the frameworkuser. This paper discusses the feasibility of using an intuitive Domain-Specific Language(DSL) for graph analysis. Specifically; we use a compiler to translate Green-Marl [5]programs into an equivalent Giraph application; automatically bridging between verydifferent programming models. We observe that the DSL programs are concise and intuitive;and that the compiler generated Giraph implementations exhibit performance on par withthat of hand-written ones. However; the DSL compilation cannot but fail if the algorithm is …,First International Workshop on Graph Data Management Experiences and Systems,2013,7
Using domain-specific languages for analytic graph databases,Martin Sevenich; Sungpack Hong; Oskar van Rest; Zhe Wu; Jayanta Banerjee; Hassan Chafi,Abstract Recently graph has been drawing lots of attention both as a natural data model thatcaptures fine-grained relationships between data entities and as a tool for powerful dataanalysis that considers such relationships. In this paper; we present a new graph databasesystem that integrates a robust graph storage with an efficient graph analytics engine.Primarily; our system adopts two domain-specific languages (DSLs); one for describinggraph analysis algorithms and the other for graph pattern matching queries. Compared tothe API-based approaches in conventional graph processing systems; the DSL-basedapproach provides users with more flexible and intuitive ways of expressing algorithms andqueries. Moreover; the DSL-based approach has significant performance benefits as well;(1)by skipping (remote) API invocation overhead and (2) by applying high-level optimization …,Proceedings of the VLDB Endowment,2016,6
System for applying transformation to improve graph analysis,*,A method for performing a neighbor-flipping transformation is provided. In one embodiment;a graph analysis program for computing a function relating to nodes in a directed graph isobtained and analyzed for neighborhood iterating operations; in which a function iscomputed over sets of nodes in the graph. For any detected neighborhood iteratingoperation; the method transforms the iterating operation by reversing the neighbor noderelationship between the nodes in the operation. The transformed operation computes thesame value for the function as the operation prior to transformation. The method alters theneighbor node relationship automatically; so that a user does not have to recode the graphanalysis program. In some cases; the method includes construction of edges in the reversedirection while retaining the original edges in addition to performing the transformation.,*,2014,6
A systematic IP and bus subsystem modeling for platform-based system design,Junhyung Um; Woo-Cheol Kwon; Sungpack Hong; Young-Taek Kim; Kyu-Myung Choi; Jeong-Taek Kong; Soo-Kwan Eo; Taewhan Kim,Abstract The topic on platform-based system modeling has received a great deal of attentiontoday. One of the important tasks that significantly affect the effectiveness and efficiency ofthe system modeling is the modeling of IP components and communication between IPs. Tobe effective; it is generally accepted that the system modeling should be performed in twosteps; In the first step; a fast but some inaccurate system modeling is considered to facilitatethe simultaneous development of software and hardware. The second step then refines themodels of the software and hardware blocks (ie; IPs) to increase the simulation accuracy forthe system performance analysis. Here; one critical factor required for a successful systemmodeling is a systematic modeling of the IP blocks and bus subsystem connecting the IPs. Inthis respect; this work addresses the problem of systematic modeling of the IPs and bus …,Proceedings of the conference on Design; automation and test in Europe: Proceedings,2006,6
Technical report: On fast parallel detection of strongly connected components (scc) in small-world graphs,Sungpack Hong; NC Rodia; K Olukotun,Abstract—Detecting strongly connected components (SCCs) in a directed graph is afundamental graph analysis algorithm that is used in many science and engineeringdomains. Traditional approaches in parallel SCC detection; however; show limitedperformance and poor scaling behavior when applied to large real-world graph instances. Inthis paper; we investigate the shortcomings of the conventional approach and propose aseries of extensions that consider the fundamental properties of real-world graphs; eg thesmall-world property. Our scalable implementation offers excellent performance on diverse;small-world graphs resulting in a 4.44 x to 23.98 x parallel speedup over the optimalsequential algorithm with 8 cores and 16 hardware threads.,*,2013,5
Data storage system including respective buffers for non-volatile memory and disc recording medium; and data access method thereof,*,A data storage system includes a non-volatile memory; a disc recording medium; a non-volatile memory buffer; operatively disposed between a host interface and the non-volatilememory; which stores a portion of data stored in the non-volatile memory; and a disc buffer;operatively disposed between the host interface and the disc recording medium; whichstores a portion of data stored in the disc recording medium. The data storage system maybe configured to receive an access address from a host operatively connected to the hostinterface; and sequentially determine whether the access address exists in one of the non-volatile memory buffer; the non-volatile memory; the disc buffer; and the disc recordingmedium; in that order.,*,2010,5
Vip: A practical approach to platform-based system modeling methodology,Jun-Hyung Um; Sung-Pack Hong; Young-Taek Kim; Eui-young Chung; Kyu-Myung Choi; Jeong-Taek Kong; Soo-Kwan Eo,Abstract Research on highly abstracted system modeling and simulation has received agreat deal of attention as of the concept of platform based design is becoming ubiquitous.From a practical design point of view; such modeling and simulation must consider thefollowing:(i) fast simulation speed and cycle accuracy;(ii) early availability for early stagesoftware development;(iii) inter-operability with external tools for software development; and(iv) reusability of the models. Unfortunately; however; all of the previous works only partiallyaddresses the requirements; due to the inherent conflicts among the requirements. Theobjective of this study is to develop a new system design methodology to effectively addressthe requirements mentioned above. We propose a new transaction-level system modelingmethodology; called ViP (Virtual Platform). We propose a two-step approach in the ViP …,JSTS: Journal of Semiconductor Technology and Science,2005,5
A Case of System-level Hardware/Software Co-design and Co-verification of a Commodity Multi-Processor System with Custom Hardware,Sungpack Hong; Tayo Oguntebi; Jared Casper; Nathan Bronson; Christos Kozyrakis; Kunle Olukotun,*,CODES+ISSS,*,5
Graph database system that dynamically compiles and executes custom graph analytic programs written in high-level; imperative programing language,*,Techniques are provided for a graph database system that accepts custom graph analyticprograms that are written in a high-level graph-specific programming language andcompiles the programs into executables that; when executed; directly access graph data of agraph that is stored in the graph database. In this way; a low-level data-access API isavoided. Also; a graph analytic program; which only describes an abstract description of analgorithm; does not include any details regarding data access. In one technique; a user isnot required to include explicit parallelization in a graph analytic program in order for thegraph analytic program to take advantage of parallelization. A compiler of the graphdatabase system identifies portions of the graph analytic program that can benefit fromparallelization and; in response; generates parallelized executable code that …,*,2016,4
Tech Report: Compiling Green-Marl into GPS,Sungpack Hong; Semih Salihoglu; Jennifer Widom; Kunle Olukotun,Abstract The massive size of the data in large graph processing requires distributedprocessing. However; conventional frameworks for distributed graph processing; such asPregel; use programming models that are well-suited for scalability but inconvenient forprogramming graph algorithms. In this paper; we use Green-Marl; a Domain-SpecificLanguage for graph analysis; to describe graph algorithms intuitively and extend its compilerto generate equivalent Pregel programs. Using the semantic information exposed by Green-Marl; the compiler applies the same kinds of transformation rules that programmers applywhen manually implementing graph algorithms with Pregel. Our experiments show that thePregel programs generated by Green-Marl compiler perform similarly to native Pregelimplementations of the same algorithms. The compiler is even able to generate a Pregel …,*,2012,4
Modeling; analysis; and experimental comparison of streaming graph-partitioning policies,Yong Guo; Sungpack Hong; Hassan Chafi; Alexandru Iosup; Dick Epema,Abstract In recent years; many distributed graph-processing systems have been designedand developed to analyze large-scale graphs. For all distributed graph-processing systems;partitioning graphs is a key part of processing and an important aspect to achieve goodprocessing performance. To keep low the overhead of partitioning graphs; even whenprocessing the ever-increasing modern graphs; many previous studies use lightweightstreaming graph-partitioning policies. Although many such policies exist; currently there isno comprehensive study of their impact on load balancing and communication overheads;and on the overall performance of graph-processing systems. This relative lack ofunderstanding hampers the development and tuning of new streaming policies; and couldlimit the entire research community to the existing classes of policies. We address these …,Journal of Parallel and Distributed Computing,2017,3
Distributed graph processing system that support remote data read with proactive bulk data transfer,*,Techniques for generating and transferring bulk messages from one computing device toanother computing device in a cluster are provided. Each computing device in a cluster isassigned a different set of nodes of a graph. A first computing device may be assigned aparticular node that is neighbors with multiple other nodes that are assigned to one or moreother computing devices in the cluster. When processing graph-related code at the firstcomputing device; information about the neighbors may be required. The first computingdevice receives a bulk message from one of the other computing devices. The bulk messagecontains information about at least a subset of the neighbors. Therefore; the first computingdevice is not required to send multiple messages for information about the subset ofneighbors. In fact; the first computing device is not required to send any message for the …,*,2016,3
Finding common neighbors between two nodes in a graph,*,Techniques for identifying common neighbors of two nodes in a graph are provided. Onetechnique involves performing a binary split search and/or a linear search. Anothertechnique involves creating a segmenting index for a first neighbor list. A second neighborlist is scanned and; for each node indicated in the second neighbor list; the segmentingindex is used to determine whether the node is also indicated in the first neighbor list.Techniques are also provided for counting the number of triangles. One technique involvespruning nodes from neighbor lists based on the node values of the nodes whose neighborlists are being pruned. Another technique involves sorting the nodes in a node array (and;thus; their respective neighbor lists) based on the nodes' respective degrees prior toidentifying common neighbors. In this way; when pruning the neighbor lists; the neighbor …,*,2015,3
Asgraph: a mutable multi-versioned graph container with high analytical performance,Michael Haubenschild; Manuel Then; Sungpack Hong; Hassan Chafi,Abstract In the last years researchers and industry have become interested in the analysis ofgraphs to gain insights into social networks; road networks; and other data that is naturallyorganized as a set of connected entities. Many of these graphs are very large; somecontaining hundreds of billions of edges. Usually; graphs are stored in static or immutablerepresentations. We propose ASGraph. ASGraph is a graph container that supports updatesand multi-versioning while still providing high analytical performance in the order ofmagnitude of the predominant CSR. ASGraph stores temporal graphs with arbitrarily finegranularity. Additionally; it can optimize its internal layout for analytical queries at specificsnapshots. We show that it has moderate runtime overhead between 7%--98% forPageRank compared to CSR. Meanwhile it outperforms CSR both in runtime and memory …,Proceedings of the Fourth International Workshop on Graph Data Management Experiences and Systems,2016,2
Efficiently counting triangles in a graph,*,Techniques for identifying common neighbors of two nodes in a graph are provided. Onetechnique involves performing a binary split search and/or a linear search. Anothertechnique involves creating a segmenting index for a first neighbor list. A second neighborlist is scanned and; for each node indicated in the second neighbor list; the segmentingindex is used to determine whether the node is also indicated in the first neighbor list.Techniques are also provided for counting the number of triangles. One technique involvespruning nodes from neighbor lists based on the node values of the nodes whose neighborlists are being pruned. Another technique involves sorting the nodes in a node array (and;thus; their respective neighbor lists) based on the nodes' respective degrees prior toidentifying common neighbors. In this way; when pruning the neighbor lists; the neighbor …,*,2016,2
In-memory graph pattern matching,*,Techniques for identifying; in a target graph; subgraphs that match a query graph areprovided. Processing a query graph comprises multiple stages; one for each query node inthe query graph. In the first stage; a query node is selected; different portions of the targetgraph are assigned to different threads; each thread identifies nodes that match the selectedquery node and stores the identities of those nodes in storage that is local to the thread. Theresults of each thread are then stored in a “global” data structure. In the second stage; asecond query node is selected and different portions of the global data structure areassigned to different threads. Each thread identifies nodes that match the second querynode and that are connected to a previously-matched node. The second stage repeats untilall nodes in the query graph are processed.,*,2016,2
Snapshot-consistent; in-memory graph instances in a multi-user database,*,Techniques for storing and processing graph data in a database system are provided. Graphdata (or a portion thereof) that is stored in persistent storage is loaded into memory togenerate an instance of a particular graph. The instance is consistent as of a particular pointin time. Graph analysis operations are performed on the instance. The instance may be usedby multiple users to perform graph analysis operations. Subsequent changes to the graphare stored separate from the instance. Later; the changes may be applied to the instance (ora copy thereof) to refresh the instance.,*,2016,2
Invalidating entries in a non-coherent cache,*,Techniques are provided for performing an invalidate operation in a non-coherent cache. Inresponse to receiving an invalidate instruction; a cache unit only invalidates cache entriesthat are associated with invalidation data. In this way; a separate invalidate instruction is notrequired for each cache entry that is to be invalidated. Also; cache entries that are not to beinvalidated remain unaffected by the invalidate operation. A cache entry may be associatedwith invalidation data if an address of the corresponding data item is in a particular set ofaddresses. The particular set of addresses may have been specified as a result of aninvalidation instruction specified in code that is executing on a processor that is coupled tothe cache.,*,2014,2
Flushing entries in a non-coherent cache,*,Techniques are provided for performing a flush operation in a non-coherent cache. Inresponse to determining to perform a flush operation; a cache unit flushes certain data items.The flush operation may be performed in response to a lapse of a particular amount of time;such as a number of cycles; or an explicit flush instruction that does not indicate any cacheentry or data item. The cache unit may store change data that indicates which entry stores adata item that has been modified but not yet been flushed. The change data may be used toidentify the entries that need to be flushed. In one technique; a dirty cache entry that isassociated with one or more relatively recent changes is not flushed during a flushoperation.,*,2014,2
Program trace method using a relational database,*,Disclosed is a method of tracing a program that comprises: providing a relational databasedata structure defining a plurality of fields configured to store program trace information;executing a program comprising a plurality of functions including calling a function from theprogram; extracting first trace data of the function and storing the first trace data in a portionof the plurality of fields; and after executing the program; extracting second trace dataassociated with the first trace data and storing the second trace data in remaining portions ofthe plurality of fields.,*,2012,2
Compiling GreenMarl into GPS,Sungpack Hong; Semih Salihoglu; Jennifer Widom; Kunle Olukotun,Abstract The massive size of the data in large graph processing requires distributedprocessing. However; conventional frameworks for distributed graph processing; such asPregel; use programming models that are well-suited for scalability but inconvenient forprogramming graph algorithms. In this paper; we use Green-Marl; a Domain-SpecificLanguage for graph analysis; to describe graph algorithms intuitively and extend its compilerto generate equivalent Pregel programs. Using the semantic information exposed by Green-Marl; the compiler applies the same kinds of transformation rules that programmers applywhen manually implementing graph algorithms with Pregel. Our experiments show that thePregel programs generated by Green-Marl compiler perform similarly to native Pregelimplementations of the same algorithms. The compiler is even able to generate a Pregel …,*,2012,2
Tie-Strength and Strategies in Social Capital Management,Sungpack Hong,One of most influential sociology studies is the concept of strength in interpersonalrelationship and its role in information spread-out through social networks. In sociology;tiestrength is a mathematical model that represents the degree of intimacy between twopeople; strong ties; as for a rough classification; correspond to close friendship and weakties to acquaintances. The surprising discovery; however; was that critical information; suchas job position; tends to flow through weak-ties rather than strong-ties. Once afterGranovetter [8] first reported this phenomenon in his Ph. D work through extensive empiricalstudies on newly hired people; it drew great attention from many researchers in sociologyand economics who tried to find a natural explanation for it. There is a group of convincingexplanations [7; 9; 10] which relate weak-ties with the structure of underlying social …,*,*,2
PGX. D/Async: A Scalable Distributed Graph Pattern Matching Engine,Nicholas P Roth; Vasileios Trigonakis; Sungpack Hong; Hassan Chafi; Anthony Potter; Boris Motik; Ian Horrocks,Abstract Graph querying and pattern matching is becoming an important feature of graphprocessing as it allows data analysts to easily collect and understand information about theirgraphs in a way similar to SQL for databases. One of the key challenges in graph patternmatching is to process increasingly large graphs that often do not fit in the memory of asingle machine. In this paper; we present PGX. D/Async; a scalable distributed patternmatching engine for property graphs that is able to handle very large datasets. PGX.D/Async implements pattern matching operations with asynchronous depth-first traversal;allowing for a high degree of parallelism and precise control over memory consumption. InPGX. D/Async; developers can query graphs with PGQL; an SQL-like query language forproperty graphs. Essentially; PGX. D/Async provides an intuitive; distributed; in-memory …,Proceedings of the Fifth International Workshop on Graph Data-management Experiences & Systems,2017,1
Intelligent compiler for parallel graph processing,*,Techniques for analyzing and modifying a graph analytic program are provided. An analyzer(such as a compiler) searches for a program portion that matches a pattern that may sufferfrom workload imbalance due to nodes with high degrees (ie; relatively many edges). Sucha pattern involves iteration over at least a subset (or all) of the nodes in a graph. If a programportion that matches the pattern is found; then the analyzer determines whether the body ofthe iteration contains an iteration over edges or neighbors of each node in the subset. If so;then the analyzer transforms the graph analytic program by adding code and; optionally;modifying existing code so that high-degree nodes are processed differently than low-degree nodes. High-degree nodes are processed sequentially while low-degree nodes areprocessed in parallel. Conversely; edges of high-degree nodes are processed in parallel …,*,2016,1
The Impact of Task Runtime Estimate Accuracy on Scheduling Workloads of Workflows,Alexey Ilyushkin; Dick Epema; Alexey Ilyushkin; Ahmed Ali-Eldin; Nikolas Herbst; André Bauer; Alessandro V Papadopoulos; Dick Epema; Alexandru Iosup; Long Cheng; Ying Wang; Yulong Pei; Dick Epema; Shenjun Ma; Alexey Ilyushkin; Alexander Stegehuis; Alexandru Iosup; Shenjun Ma; Alexey Ilyushkin; Alexander Stegehuis; Alexandru Iosup; Bogdan Ghit; Dick Epema; Alexey Ilyushkin; Ahmed Ali-Eldin; Nikolas Herbst; Alessandro Papadopoulos; Bogdan Ghit; Dick Epema; Alexandru Iosup; Yong Guo; Sungpack Hong; Hassan Chafi; Alexandru Iosup; Dick Epema; Alexandru Iosup; Radu Prodan; Alexandru Iosup; Adele Lu Jia; Siqi Shen; Dick Epema; Alexandru Iosup; Ahmed Ali-Eldin; Alexey Ilyushkin; Bogdan Ghit; Nikolas Roman Herbst; Alessandro Papadopoulos; Alexandru Iosup; Henri Bal; Dick Epema; Cees de Laat; Rob van Nieuwpoort; John Romein; Frank Seinstra; Cees Snoek; Harry Wijshoff; Aleksandra Kuzmanovska; Rudolf Mak; Dick Epema; Aleksandra Kuzmanovska; Rudolf Mak; Dick Epema; Bogdan Ghit; Dick Epema; Yong Guo; Ana Lucia Varbanescu; Dick Epema; Alexandru Iosup; Jie Shen; Ana Lucia Varbanescu; Yutong Lu; Peng Zou; Henk Sips; A Kuzmanovska; RH Mak; DHJ Epema,abstract={The audio Beamforming (BF) technique utilizes microphone arrays to extractacoustic sources recorded in a noisy environment. In this article; we propose a newapproach for rapid development of multicore BF systems. Research on literature reveals thatthe majority of such experimental and commercial audio systems are based on desktop PCs;due to their high-level programming support and potential of rapid system development.However; these approaches introduce performance bottlenecks; excessive powerconsumption; and increased overall cost. Systems based on DSPs require very low power;but their performance is still limited. Custom hardware solutions alleviate theaforementioned drawbacks; however; designers primarily focus on performanceoptimization without providing a high-level interface for system control and test. In order to …,18th IEEE/ACM International Symposium on Cluster; Grid and Cloud Computing,2016,1
Automatic Selection Of An Abstract Data Type,*,An abstract data type is a data type defined in effect by semantics of operations performed onthe data type. In a program; abstract data types may only be accessed by these operations. Implementationsof abstract data types and the operations that define the abstract data types are provided separatelyand may not be exposed to a programmer. There can be many different implementations foran abstract data type; however; the different implementations each support and honor the semanticsof the operations … The choice of implementation for abstract data types can greatly affect theperformance of a program. Poor choice of implementation often leads to poor performance ofthe program. There may be no one-size-fits-all implementation of an abstract data type whichperforms best for every use case … Typically; programmers choose the best implementationof the abstract data types for programs. Programmers may choose an existing …,*,2015,1
Memory fast-forward: A low cost special function unit to enhance energy efficiency in GPU for big data processing,Eunhyeok Park; Junwhan Ahn; Sungpack Hong; Sungjoo Yoo; Sunggu Lee,Abstract Big data processing; eg; graph computation and MapReduce; is characterized bymassive parallelism in computation and a large amount of fine-grained random memoryaccesses often with structural localities due to graph-like data dependency. Recently; GPUis gaining more and more attention for servers due to its capability of parallel computation.However; the current GPU architecture is not well suited to big data workloads due to thelimited capability of handling a large number of memory requests. In this paper; we present aspecial function unit; called memory fast-forward (MFF) unit; to address this problem. Ourproposed MFF unit provides two key functions. First; it supports pointer chasing whichenables computation threads to issue as many memory requests as possible to increase thepotential of coalescing memory requests. Second; it coalesces memory requests bound …,Proceedings of the 2015 Design; Automation & Test in Europe Conference & Exhibition,2015,1
Modeling; Analysis; and Experimental Comparison of Streaming Graph-Partitioning Policies: A Technical Report,Yong Guo; Sungpack Hong; Hassan Chafi; Alexandru Iosup; Dick Epema,Abstract In recent years; many distributed graph-processing systems have been designedand developed to analyze large-scale graphs. For all distributed graph-processing systems;partitioning graphs is a key part of processing and an important aspect of achieve goodprocessing performance. To keep low the performance of partitioning graphs; even whenprocessing the ever-increasing modern graphs; many previous studies use lightweightstreaming graph-partitioning policies. Although many such policies exist; currently there isno comprehensive study of their impact on load balancing and communication overheads;and on the overall performance of graph-processing systems. This relative lack ofunderstanding hampers the development and tuning of new streaming policies; and couldlimit the entire research community to the existing classes of policies. We address these …,Delft University of Technology; Tech. Rep. PDS-2015-002,2015,1
Data storage system including respective buffers for non-volatile memory and disc recording medium; and data access method thereof,*,A data storage system includes a non-volatile memory; a disc recording medium; a non-volatile memory buffer; operatively disposed between a host interface and the non-volatilememory; which stores a portion of data stored in the non-volatile memory; and a disc buffer;operatively disposed between the host interface and the disc recording medium; whichstores a portion of data stored in the disc recording medium. The data storage system maybe configured to receive an access address from a host operatively connected to the hostinterface; and sequentially determine whether the access address exists in one of the non-volatile memory buffer; the non-volatile memory; the disc buffer; and the disc recordingmedium; in that order.,*,2011,1
Concurrent distributed graph processing system with self-balance,*,Abstract Techniques are provided for dynamically self-balancing communication andcomputation. In an embodiment; each partition of application data is stored on a respectivecomputer of a cluster. The application is divided into distributed jobs; each of whichcorresponds to a partition. Each distributed job is hosted on the computer that hosts thecorresponding data partition. Each computer divides its distributed job into computationtasks. Each computer has a pool of threads that execute the computation tasks. Duringexecution; one computer receives a data access request from another computer. The dataaccess request is executed by a thread of the pool. Threads of the pool are bimodal and maybe repurposed between communication and computation; depending on workload. Eachcomputer individually detects completion of its computation tasks. Each computer informs …,*,2017,*
METHOD OF ACHIEVING INTRA-MACHINE WORKLOAD BALANCE FOR DISTRIBUTED GRAPH-PROCESSING SYSTEMS,*,Abstract: Techniques are provided for efficiently distributing graph data to multiple processorthreads located on a server node. The server node receives graph data to be processed bythe server node of a graph processing system. The received graph data is a portion of alarger graph to be processed by the graph processing system. In response to receivinggraph data the server node compiles a list of vertices and attributes of each vertex from thegraph data received. The server node then creates task chunks of work based upon thecompiled list of vertices and their corresponding attribute data. The server node thendistributes the task chunks to a plurality of threads available on the server node.,*,2017,*
Graph analytic engine that implements efficient transparent remote access over representational state transfer,*,Abstract Techniques herein decouple available results; from graph analysis execution; toadapt to various deployment configurations. In an embodiment; a graph engine is deployedthat has multiple mutually-exclusive configuration modes that include being embeddedwithin a software application; centrally serving software applications; or distributed amongsta cluster of computers. Based on a current configuration mode of the graph engine; asoftware application receives or generates an analysis request to process a graph. Thesoftware application provides the analysis request to the graph engine in exchange foraccess to a computational future; of the graph engine; that is based on the analysis requestand the graph. Based on a proxy of said computational future; the software applicationaccesses a result of the analysis request. In an embodiment; a remote proxy exchanges …,*,2017,*
Graph processing system that can define a graph view from multiple relational database tables,*,Techniques are provided for mapping tables and columns of a legacy relational schema intosynthetic tables that are dedicated for graph analysis. In an embodiment; a computerreceives a mapping of relational tables to node tables and edge tables. The node tablescontain columns and rows. The edge tables contain columns and rows. The rows of thenode tables and the rows of the edge tables define a graph. Based on the mapping and therelational tables; the computer calculates a value of at least one column of at least one rowof the node tables. Based on an execution of a query of the graph; the computer returns thevalue.,*,2017,*
In-memory data analytic system that provides an integrated tracking mechanism for explicit memory resources,*,Techniques and a system are provided for managing resources used by user-providedprograms. The system includes an application programming interface (API) that allows user-provided programs to access memory resources managed by functions provided by the API.The system stores memory-usage records made during memory allocations. Memory-usagerecords may be used to identify memory resources; analyze memory usage; and provideother features.,*,2017,*
Reducing synchronization of tasks in latency-tolerant task-parallel systems,*,Techniques are provided for reducing synchronization of tasks in a task scheduling system.A task queue includes multiple tasks; some of which require an I/O operation while othertasks require data stored locally in memory. A single thread is assigned to process tasks inthe task queue. The thread determines if a task at the head of the task queue requires an I/Ooperation. If so; then the thread generates an I/O request; submits the I/O request; and mayplace the task at (or toward) the end of the task queue. When the task reaches the head ofthe task queue again; the thread determines if data requested by the I/O request is availableyet. If so; then the thread processes the request. Otherwise; the thread may place the task at(or toward) the end of the task queue again.,*,2017,*
Method of achieving intra-machine workload balance for task chunks for distributed graph-processing systems,*,Techniques are provided for efficiently distributing graph data to multiple processor threadslocated on a server node. The server node receives graph data to be processed by theserver node of a graph processing system. The received graph data is a portion of a largergraph to be processed by the graph processing system. In response to receiving graph datathe server node compiles a list of vertices and attributes of each vertex from the graph datareceived. The server node then creates task chunks of work based upon the compiled list ofvertices and their corresponding attribute data. The server node then distributes the taskchunks to a plurality of threads available on the server node.,*,2017,*
Efficient method for subgraph pattern matching,*,Techniques herein optimize subgraph pattern matching. A computer receives a graph vertexarray and a graph edge array. Each vertex and each edge has labels. The computer storesan array of index entries and an array of edge label sets. Each index entry corresponds to arespective vertex originating an edge and associates an offset of the edge with an offset ofthe respective vertex. Each edge label set contains labels of a respective edge. Thecomputer selects a candidate subset of edges originating at a current vertex. The edgelabels of each candidate edge of the candidate subset include a same particular query edgelabels. The computer selects the candidate subset based on the index array and afterwardsselects a result subset of vertices from among the terminating vertices of the candidateedges. The labels of each vertex of the result subset include a same particular query …,*,2017,*
Automated generation of memory consumption aware code,*,Techniques generate memory-optimization logic for concurrent graph analysis. A computeranalyzes domain-specific language logic that analyzes a graph having vertices and edges.The computer detects parallel execution regions that create thread locals. Each thread localis associated with a vertex or edge. For each parallel region; the computer calculates howmuch memory is needed to store one instance of each thread local. The computer generatesinstrumentation that determines how many threads are available and how many vertices andedges will create thread locals. The computer generates tuning logic that determines howmuch memory is originally needed for the parallel region based on how much memory isneeded to store the one instance; how many threads are available; and graph size. Thetuning logic detects a memory shortage based on the original amount of memory needed …,*,2017,*
A Load-Balanced Parallel and Distributed Sorting Algorithm Implemented with PGX. D,Zahra Khatami; Sungpack Hong; Jinsoo Lee; Siegfried Depner; Hassan Chafi; J Ramanujam; Hartmut Kaiser,Sorting has been one of the most challenging studied problems in different scientificresearches. Although many techniques and algorithms have been proposed on the theory ofhaving efficient parallel sorting implementation; however achieving desired performance ondifferent types of the architectures with large number of processors is still a challengingissue. Maximizing parallelism level in applications can be achieved by minimizingoverheads due to load imbalance and waiting time due to memory latencies. In this paper;we present a distributed sorting algorithm implemented in PGX. D; a fast distributed graphprocessing system; which outperforms the Spark's distributed sorting implementation byaround 2x-3x by hiding communication latencies and minimizing unnecessary overheads.Furthermore; it shows that the proposed PGX. D sorting method handles dataset …,Parallel and Distributed Processing Symposium Workshops (IPDPSW); 2017 IEEE International,2017,*
Efficient method for indexing data transferred between machines in distributed graph processing systems,*,Techniques herein index data transferred during distributed graph processing. In anembodiment; a system of computers divides a directed graph into partitions. The systemcreates one partition per computer and distributes each partition to a computer. Eachcomputer builds four edge lists that enumerate edges that connect the partition of thecomputer with a partition of a neighbor computer. Each of the four edge lists has edges of adirection; which may be inbound or outbound from the partition. Edge lists are sorted byidentifier of the vertex that terminates or originates each edge. Each iteration of distributedgraph analysis involves each computer processing its partition and exchanging edge data orvertex data with neighbor computers. Each computer uses an edge list to build a compactlydescribed range of edges that connect to another partition. The computers exchange …,*,2017,*
Fast processing of path-finding queries in large graph databases,*,Techniques herein are for fast processing of path-finding queries in large graph databases.A computer system receives a graph search request to find a set of result paths between oneor more source vertices of a graph and one or more target vertices of the graph. The graphcomprises vertices connected by edges. During a first pass; the computer system performsone or more breadth-first searches to identify a subset of edges of the graph. The one ormore breadth-first searches originate at the one or more source vertices. After the first passand during a second pass; the computer system performs one or more depth-first searchesto identify the set of result paths. The one or more depth-first searches originate at the one ormore target vertices. The one or more depth-first searches traverse at most the subset ofedges of the graph.,*,2017,*
Advanced interactive command-line front-end for graph analysis systems,*,Systems and methods for interactive front-end graph analysis are provided herein.According to one embodiment; a front-end application receives; from a compiler; first meta-information for a particular graph analysis procedure; where the first meta-informationidentifies a set of input parameters for passing graph information to the particular graphanalysis procedure. The front-end application registers; using the first meta-information; theparticular graph analysis procedure as an available command. The front-end applicationalso receives second meta-information that identifies; for each respective graph object of aset of one or more graph objects; a respective set of graph characteristics. In response toreceiving a request to apply the particular graph analysis procedure to the set of one or moregraph objects; the front-end application enforces a set of one or more constraints based …,*,2017,*
Graph data processing system that supports automatic data model conversion from resource description framework to property graph,*,A graph processing system that supports automatic data model conversion from ResourceFramework Description (RDF) to Property Graph (PG) is provided. Rather than using a naiveconversion approach that creates PG nodes and edges without properties; a set ofconversion rules is evaluated to automatically convert RDF triples into PG nodes and edgeswith properties; as appropriate. Accordingly; the converted PG data takes full advantage ofthe PG format while advantageously avoiding the creation of extraneous nodes and edges;allowing queries on the PG data to be efficiently executed on any database supporting thePG data model. The plurality of rules categorize each triple into three different casesdepending on whether or not the predicate is “rdf: type” and whether or not the object is aliteral value; generating graph entities as appropriate for each case. Optionally; user …,*,2017,*
Optimization techniques for high-level graph language compilers,*,Techniques for optimizing program code through property merging are described. In anembodiment; a compiler identifies; from a plurality of properties of a particular data objectthat are referenced by the program code; one or more candidate sets of properties that areeligible for merging. For a respective candidate set of properties of the one or morecandidate set of properties; the compiler determines whether to merge different properties ofthe particular data object that belong to the respective candidate set of properties. Afterdetermining to merge the different properties; a particular data structure is generated; withinthe memory of a computing device; that stores the different properties of the particular dataobject that belong to the respective candidate set.,*,2017,*
Latency-hiding context management for concurrent distributed tasks in a distributed system,*,Techniques are provided for latency-hiding context management for concurrent distributedtasks. A plurality of task objects is processed; including a first task object corresponding to afirst task that includes access to first data residing on a remote machine. A first accessrequest is added to a request buffer. A first task reference identifying the first task object isadded to a companion buffer. A request message including the request buffer is sent to theremote machine. A response message is received; including first response data responsiveto the first access request. For each response of one or more responses of the responsemessage; the response is read from the response message; a next task reference is readfrom the companion buffer; and a next task corresponding to the next task reference iscontinued based on the response. The first task is identified and continued.,*,2017,*
Textual query editor for graph databases that performs semantic analysis using extracted information,*,Techniques herein are for query editing with semantic analysis of a query based oninformation extracted from a tuple graph. In an embodiment; a computerized methodinvolves processing a dataset to extract an extracted schema that describes types andrelationships that occur within the dataset. The dataset is not associated with a schema thatis not contained in the dataset. The dataset has a graph of tuples. During an incrementalparse; an abstract syntax tree (AST) that represents a query is modified. The extractedschema and the dataset are used to perform semantic analysis on the AST. In anembodiment; the tuples are resource description framework (RDF) triples. In anembodiment; the RDF triples include RDF schema statements. Extracting an extractedschema involves processing RDF schema statements. In an embodiment; the query is a …,*,2016,*
Automatic generation of multi-source breadth-first search from high-level graph language,*,Techniques are described herein for automatic generation of multi-source breadth-firstsearch (MS-BFS) from high-level graph processing language. In an embodiment; a methodinvolves a computer analyzing original software instructions. The original softwareinstructions are configured to perform multiple breadth-first searches to determine aparticular result. Each breadth-first search originates at each of a subset of vertices of agraph. Each breadth-first search is encoded for independent execution. Based on theanalyzing; the computer generates transformed software instructions configured to perform aMS-BFS to determine the particular result. Each of the subset of vertices is a source of theMS-BFS. In an embodiment; parallel execution of the MS-BFS is regulated with batches ofvertices. In an embodiment; the original software instructions are expressed in Green …,*,2016,*
A Balanced Parallel Distributed Sorting Implemented with PGX. D,Zahra Khatami; Sungpack Hong; Jinsu Lee; Siegfried Depner; Hassan Chafi,Abstract: Sorting has been one of the most challenging studied problems in differentscientific researches. Although many techniques and algorithms has been proposed on thetheory of efficient parallel sorting implementation; however achieving the desiredperformance on the variety of architectures with the large number of processors is still thechallenging issue. Maximizing the parallelism level in the application can be achieved byminimizing the overhead due to load imbalance and waiting time due to the memorylatencies. In this paper; we present a distributed sorting implemented in PGX. D; a fastdistributed graph processing system; which outperforms Spark distributed sorting by around2x-3x by hiding communication latencies and minimizing unnecessary overheads.Furthermore; it shows that the proposed PGX. D sorting method handles duplicated data …,arXiv preprint arXiv:1611.00463,2016,*
Graph-data partitioning for workload-balanced distributed computation with cost estimation functions,*,Techniques herein perform workload-balanced graph partitioning. Each graph partition isdistributed to a respective computer. Each computer applies a workload-estimation functionto its partition to calculate a numeric workload-value that indicates how much computationthe partition needs. Each computer sends its numeric workload-value to a master computer.The master compares the highest and lowest numeric workload-values. If the differenceexceeds a threshold; the master detects how much work should overloaded-computersoffload to under-utilized computers. To each overloaded-computer; the master sends adirective with a balancing numeric workload-value that indicates how much computation tooffload and an identifier of an under-utilized computer to receive the offload. Based on thisdirective and the workload-estimation function; an overloaded-computer selects a portion …,*,2016,*
Constructing an in-memory representation of a graph,*,Techniques for efficiently loading graph data into memory are provided. A plurality of nodeID lists are retrieved from storage. Each node ID list is ordered based on one or more ordercriteria; such as node ID; and is read into memory. A new list of node IDs is created inmemory and is initially empty. From among the plurality of node ID lists; a particular node IDis selected based on the one or more order criteria; removed from the node ID list where theparticular node ID originates; and added to the new list. This process of selecting; removing;and adding continues until no more than one node ID list exists; other than the new list. Inthis way; the retrieval of the plurality of node ID lists from storage may be performed inparallel while the selecting and adding are performed sequentially.,*,2016,*
Efficient regular path query evaluation in PGX,Xuming Meng,Nowadays; available data on the Internet grows extremely rapidly in terms of volume;velocity and variety. Efficient management of such huge amount of data has appealed toboth industry and academia. However; the data model used by traditional relationaldatabase management system does not fit in all user cases; such as semantic web [7]; socialnetwork [5; 49; 42]; biological network [39; 40]. The relational model [43] represents data astuples; groups them into relations. Each relation has unique primary/-foreign key used toindicate hidden data connections. The major drawback of this model is expensive discoveryof data connection via join operation. Usually; queries involving many link discovery tend tobe processed inefficiently. Another downside of relational data model is lack of explicitrepresentation of connection between data items; resulting in limits on expressiveness of …,*,2016,*
Bus Optimization for Low Power in High-Level Synthesis,Sungpack Hong; Taewhan Kim,Sub-micron feature sizes have resulted in a considerable portion of power to be dissipatedon the buses; causing an increased attention on savings for power at the behavioral leveland the RT level of design. This paper addresses the problem of minimizing powerdissipated in the switching of the buses in the high-level synthesis of data-dominatedbehavioral descriptions. Unlike the previous approaches in which the minimization of thepower consumed in buses has not been considered until operation scheduling is completed;our approach integrates the bus binding problem into scheduling to exploit the impact ofscheduling on the reduction of power dissipated on the buses more fully and effectively. Weaccomplish this by formulating the problem into a flow problem in a network; and devising anefficient algorithm which iteratively finds the maximum flow of minimum cost solutions in …,Journal of Circuits; Systems; and Computers,2003,*
A Data-Centric Parallel Architecture for High Performance Graph Processing,Tayo Oguntebi; Nicole Rodia; Sungpack Hong; Kunle Olukotun,• Shared memory multi-core (eg x86/SPARC servers)+ Inexpensive commodity hardware−Multi-level caches–low locality performs poorly− Non-uniform memory access time for multi-socket− Limited number of system threads• Massively multithreaded (eg Cray XMT)+ Manycores and threads hide memory latency+ Shared address space with uniform memoryaccess time,Crossings,*,*
