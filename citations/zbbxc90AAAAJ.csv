H-store: a high-performance; distributed main memory transaction processing system,Robert Kallman; Hideaki Kimura; Jonathan Natkins; Andrew Pavlo; Alexander Rasin; Stanley Zdonik; Evan PC Jones; Samuel Madden; Michael Stonebraker; Yang Zhang; John Hugg; Daniel J Abadi,Abstract Our previous work has shown that architectural and application shifts have resultedin modern OLTP databases increasingly falling short of optimal performance [10]. Inparticular; the availability of multiple-cores; the abundance of main memory; the lack of userstalls; and the dominant use of stored procedures are factors that portend a clean-slateredesign of RDBMSs. This previous work showed that such a redesign has the potential tooutperform legacy OLTP databases by a significant factor. These results; however; wereobtained using a bare-bones prototype that was developed just to demonstrate the potentialof such a system. We have since set out to design a more complete execution platform; andto implement some of the ideas presented in the original paper. Our demonstrationpresented here provides insight on the development of a distributed main memory OLTP …,Proceedings of the VLDB Endowment,2008,439
A demonstration of SciDB: a science-oriented DBMS,Philippe Cudré-Mauroux; Hideaki Kimura; K-T Lim; Jennie Rogers; Roman Simakov; Emad Soroush; Pavel Velikhov; Daniel L Wang; Magdalena Balazinska; Jacek Becla; D DeWitt; Bobbi Heath; David Maier; Samuel Madden; J Patel; Michael Stonebraker; S Zdonik,Abstract In CIDR 2009; we presented a collection of requirements for SciDB; a DBMS thatwould meet the needs of scientific users. These included a nested-array data model; science-specific operations such as regrid; and support for uncertainty; lineage; and named versions.In this paper; we present an overview of SciDB's key features and outline a demonstration ofthe first version of SciDB on data and operations from one of our lighthouse users; the LargeSynoptic Survey Telescope (LSST).,Proceedings of the VLDB Endowment,2009,153
FOEDUS: OLTP Engine for a Thousand Cores and NVRAM,Hideaki Kimura,Abstract Server hardware is about to drastically change. As typified by emerging hardwaresuch as UC Berkeley's Firebox project and by Intel's Rack-Scale Architecture (RSA); nextgeneration servers will have thousands of cores; large DRAM; and huge NVRAM. Weanalyze the characteristics of these machines and find that no existing database isappropriate. Hence; we are developing FOEDUS; an open-source; from-scratch databaseengine whose architecture is drastically different from traditional databases. It extends in-memory database technologies to further scale up and also allows transactions to efficientlymanipulate data pages in both DRAM and NVRAM. We evaluate the performance ofFOEDUS in a large NUMA machine (16 sockets and 240 physical cores) and find thatFOEDUS achieves multiple orders of magnitude higher TPC-C throughput compared to H …,SIGMOD '15 Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data,2015,57
Foster B-Trees,Goetz Graefe; Hideaki Kimura; Harumi Kuno,Abstract Foster B-trees are a new variant of B-trees that combines advantages of prior B-treevariants optimized for many-core processors and modern memory hierarchies with flashstorage and nonvolatile memory. Specific goals include:(i) minimal concurrency controlrequirements for the data structure;(ii) efficient migration of nodes to new storage locations;and (iii) support for continuous and comprehensive self-testing. Like B link-trees; Foster B-trees optimize latching without imposing restrictions or specific designs on transactionallocking; for example; key range locking. Like write-optimized B-trees; and unlike B link-trees;Foster B-trees enable large writes on RAID and flash devices as well as wear leveling andefficient defragmentation. Finally; they support continuous and inexpensive yetcomprehensive verification of all invariants; including all cross-node invariants of the B …,ACM Transactions on Database Systems (TODS),2012,49
CORADD: Correlation aware database designer for materialized views and indexes,Hideaki Kimura; George Huo; Alexander Rasin; Samuel Madden; Stanley B Zdonik,Abstract We describe an automatic database design tool that exploits correlations betweenattributes when recommending materialized views (MVs) and indexes. Although there is asubstantial body of related work exploring how to select an appropriate set of MVs andindexes for a given workload; none of this work has explored the effect of correlatedattributes (eg; attributes encoding related geographic information) on designs. Our toolidentifies a set of MVs and secondary indexes such that correlations between the clusteredattributes of the MVs and the secondary indexes are enhanced; which can dramaticallyimprove query performance. It uses a form of Integer Linear Programming (ILP) called ILPFeedback to pick the best set of MVs and indexes for given database size constraints. Wecompare our tool with a state-of-the-art commercial database designer on two workloads …,Proceedings of the VLDB Endowment,2010,46
In-memory performance for big data,Goetz Graefe; Haris Volos; Hideaki Kimura; Harumi Kuno; Joseph Tucek; Mark Lillibridge; Alistair Veitch,Abstract When a working set fits into memory; the overhead imposed by the buffer poolrenders traditional databases non-competitive with in-memory designs that sacrifice thebenefits of a buffer pool. However; despite the large memory available with modernhardware; data skew; shifting workloads; and complex mixed workloads make it difficult toguarantee that a working set will fit in memory. Hence; some recent work has focused onenabling in-memory databases to protect performance when the working data set almost fitsin memory. Contrary to those prior efforts; we enable buffer pool designs to match in-memoryperformance while supporting the" big data" workloads that continue to require secondarystorage; thus providing the best of both worlds. We introduce here a novel buffer pool designthat adapts pointer swizzling for references between system objects (as opposed to …,Proceedings of the VLDB Endowment,2014,28
Correlation maps: a compressed access method for exploiting soft functional dependencies,Hideaki Kimura; George Huo; Alexander Rasin; Samuel Madden; Stanley B Zdonik,Abstract In relational query processing; there are generally two choices for access pathswhen performing a predicate lookup for which no clustered index is available. One option isto use an unclustered index. Another is to perform a complete sequential scan of the table.Many analytical workloads do not benefit from the availability of unclustered indexes; thecost of random disk I/O becomes prohibitive for all but the most selective queries. It has beenobserved that a secondary index on an unclustered attribute can perform well under certainconditions if the unclustered attribute is correlated with a clustered index attribute [4]. Theclustered index will co-locate values and the correlation will localize access through theunclustered attribute to a subset of the pages. In this paper; we show that in a realapplication (SDSS) and widely used benchmark (TPC-H); there exist many cases of …,Proceedings of the VLDB Endowment,2009,25
Ss-db: A standard science dbms benchmark,Philippe Cudre-Mauroux; Hideaki Kimura; Kian-Tat Lim; Jennie Rogers; Samuel Madden; Michael Stonebraker; Stanley B Zdonik; Paul G Brown,*,Under submission,2010,21
Efficient locking techniques for databases on modern hardware.,Hideaki Kimura; Goetz Graefe; Harumi A Kuno,ABSTRACT Traditional database systems are driven by the assumption that disk I/O is theprimary bottleneck; overshadowing all other costs. However; future database systems will bedominated by many-core processors; large main memory; and low-latency semiconductormass storage. In the increasingly common case that the working data set fits in memory orlow-latency storage; new bottlenecks emerge: locking; latching; logging; and critical sectionsin the buffer manager. Prior work has addressed two of these–latching and logging. Thispaper addresses locking and proposes new mechanisms optimized for modern hardware.We devised new algorithms and methods to improve all components of database locking;including key range locking; intent locks; detection and recovery from deadlocks; and earlylock release. Most of the techniques are easily applicable to other database systems …,ADMS@ VLDB,2012,20
Upi: A primary index for uncertain databases,Hideaki Kimura; Samuel Madden; Stanley B Zdonik,Abstract Uncertain data management has received growing attention from industry andacademia. Many efforts have been made to optimize uncertain databases; including thedevelopment of special index data structures. However; none of these efforts have exploredprimary (clustered) indexes for uncertain databases; despite the fact that clustering has thepotential to offer substantial speedups for non-selective analytic queries on large uncertaindatabases. In this paper; we propose a new index called a UPI (Uncertain Primary Index)that clusters heap files according to uncertain attributes with both discrete and continuousuncertainty distributions. Because uncertain attributes may have several possible values; aUPI on an uncertain attribute duplicates tuple data once for each possible value. To preventthe size of the UPI from becoming unmanageable; its size is kept small by placing low …,Proceedings of the VLDB Endowment,2010,16
Mostly-optimistic concurrency control for highly contended dynamic workloads on a thousand cores,Tianzheng Wang; Hideaki Kimura,Abstract Future servers will be equipped with thousands of CPU cores and deep memoryhierarchies. Traditional concurrency control (CC) schemes---both optimistic and pessimistic---slow down orders of magnitude in such environments for highly contended workloads.Optimistic CC (OCC) scales the best for workloads with few conflicts; but suffers fromclobbered reads for high conflict workloads. Although pessimistic locking can protect reads;it floods cache-coherence backbones in deep memory hierarchies and can also causenumerous deadlock aborts. This paper proposes a new CC scheme; mostly-optimisticconcurrency control (MOCC); to address these problems. MOCC achieves orders ofmagnitude higher performance for dynamic workloads on modern servers. The key objectiveof MOCC is to avoid clobbered reads for high conflict workloads; without any centralized …,Proceedings of the VLDB Endowment,2016,12
Methods and systems for an intent lock engine,*,In at least some examples; a system may include a processor core and a non-transitorycomputer-readable memory in communication with the processor core. The non-transitorycomputer-readable memory may store an intent lock engine to manage intent locks basedon a private lock table for each process associated with said processor core and a globallock table for a plurality of processes associated with at least one of a plurality of processorcores including said processor core.,*,2014,12
Compression aware physical database design,Hideaki Kimura; Vivek Narasayya; Manoj Syamala,Abstract Modern RDBMSs support the ability to compress data using methods such as nullsuppression and dictionary encoding. Data compression offers the promise of significantlyreducing storage requirements and improving I/O performance for decision support queries.However; compression can also slow down update and query performance due to the CPUcosts of compression and decompression. In this paper; we study how data compressionaffects choice of appropriate physical database design; such as indexes; for a givenworkload. We observe that approaches that decouple the decision of whether or not tochoose an index from whether or not to compress the index can result in poor solutions.Thus; we focus on the novel problem of integrating compression into physical databasedesign in a scalable manner. We have implemented our techniques by modifying …,Proceedings of the VLDB Endowment,2011,6
Methods and systems for deadlock detection,*,In at least some examples; a system may include a processor core and a non-transitorycomputer-readable memory in communication with the processor core. The non-transitorycomputer-readable memory may store deadlock detection engine to determine a deadlockcondition; wherein the deadlock detection engine accounts for a set of database lock modes.,*,2014,5
Be my guest: MCS lock now welcomes guests,Tianzheng Wang; Milind Chabbi; Hideaki Kimura,Abstract The MCS lock is one of the most prevalent queuing locks. It provides fair schedulingand high performance on massively parallel systems. However; the MCS lock mandates abring-your-own-context policy: each lock user must provide an additional context (ie; aqueue node) to interact with the lock. This paper proposes MCSg; a variant of the MCS lockthat relaxes this restriction. Our key observation is that not all lock users are created equal.We analyzed how locks are used in massively-parallel modern systems; such as NUMA-aware operating systems and databases. We found that such systems often have a smallnumber of" regular" code paths that enter the lock very frequently. Such code paths are theprimary beneficiary of the high scalability of MCS locks.,ACM SIGPLAN Notices,2016,4
Orthogonal key-value locking,Goetz Graefe; Hideaki Kimura,B-trees have been ubiquitous for decades; and over the past 20 years; record-level lockinghas been ubiquitous in b-tree indexes. There are multiple designs; each a different tradeoffbetween (i) high concurrency and a fine granularity of locking for updates;(ii) efficient coarselocks for equality and range queries;(iii) run time efficiency with the fewest possibleinvocations of the lock manager; and (iv) conceptual simplicity for efficient development;maintenance; and testing. A new design introduced here is efficient and simple yet supportsboth fine and coarse granularities of locking. A lock request may cover (i) a gap (openinterval) between two (actual) key values;(ii) a key value with its entire list of (actual andpossible) row identifiers (in a non-unique secondary index);(iii) a specific pair of key valueand row identifier; or (iv) a distinct key value and a fraction of all (actual and possible) row …,Datenbanksysteme für Business; Technologie und Web (BTW 2015),2015,4
Optimizing index deployment order for evolving OLAP,Hideaki Kimura; Carleton Coffrin; Alexander Rasin; Stanley B Zdonik,Abstract Many database applications deploy hundreds or thousands of indexes to speed upquery execution. Despite a plethora of prior work on index selection; designing anddeploying indexes remains a difficult task for database administrators. First; real-worldbusinesses often require online index deployment; and the traditional off-line approach toindex selection ignores intermediate workload performance during index deployment.Second; recent work on on-line index selection does not address effects of complexinteractions that manifest during index deployment. In this paper; we propose a newapproach that incorporates transitional design performance into the overall problem ofphysical database design. We call our approach Incremental Database Design. As the firststep in this direction; we study the problem of ordering index deployment. The benefits of …,Proceedings of the 15th International Conference on Extending Database Technology,2012,3
Early release of transaction locks based on tags,*,A computing system is associated with a first transaction and a second transaction. The firsttransaction is associated with an update to data and a release of at least one lock on thedata prior to the first transaction being durable. The at least one lock is associated withand/or replaced with at least one tag. The computing system is to identify that the secondtransaction is to acquire the at least one tag based on a read of the data; determine whetherthe first transaction is durable based on the at least one tag; and delay a transaction commitfor the second transaction until the first transaction is durable.,*,2014,2
Mostly-Optimistic Concurrency Control for Highly Contended Dynamic Workloads on a Thousand Cores (Extended Version),Tianzheng Wang; Hideaki Kimura,Abstract: Future servers will be equipped with thousands of CPU cores and deep memoryhierarchies. Traditional concurrency control (CC) schemes--both optimistic and pessimistic--slow down orders of magnitude in such environments for highly contended workloads.Optimistic CC (OCC) scales the best for workloads with few conflicts; but suffers fromclobbered reads for high conflict workloads. Although pessimistic locking can protect reads;it floods cache-coherence backbones in deep memory hierarchies and can also causenumerous deadlock aborts.,Hewlett Packard Labs Technical Report HPE-2016,2016,1
Custom query execution engine,*,A custom query execution engine can be generated that captures a query. More particularly;the custom query execution engine can be generated based on combination of a query andan execution engine. Subsequent to generation; a custom query execution engine can besubmitted to a system configured to execute the custom query execution engine andevaluate the query over a data store.,*,2015,1
Compression aware physical database design,*,A plurality of indicators representing a plurality of respective candidate databaseconfigurations may be obtained; each of the candidate database configurations including aplurality of database queries and a plurality of candidate database indexes associated witha database table. A portion of the candidate database indexes included in the plurality ofdatabase indexes may be selected based on skyline selection. An enumeration of theportion of the plurality of the candidate database indexes may be determined based on agreedy algorithm.,*,2015,1
Making Transaction Execution the Bottleneck,Harumi Kuno; Goetz Graefe; Hideaki Kimura,Abstract Traditional database systems rely upon a proven set of tools to guarantee ACIDproperties without compromising performance: a buffer manager to mediate the transfer ofdata between fast in-memory processing and slow disk-based persistent storage; latchingand locking to coordinate concurrent access to data; and logging to enable the recovery;verification; and repair of committed data. These tools are built on code bases that are 10-30years old and designed for hardware assumptions nearly the same age. Modern hardwaretechnologies such as fast persistent memories and multicore break those assumptions;turning the traditional proven tools into the new bottlenecks. Our goal is to rethink thetraditional tools so that they will not be bottlenecks. Here; we review some of theconcurrency-related bottlenecks that face the modern transactional storage management …,International Workshop on Databases in Networked Information Systems,2013,1
Foster twin data structure,*,Abstract Example implementation disclosed herein include techniques for methods;systems; and devices for a foster twin data structure. The data structure includes data pages;keys; and pointers. The pointers define hierarchical parent-child relationships among thedata pages based on the keys. Transactions that result in inserts into the data pages arehandled using foster twin data pages that split key ranges and the corresponding datarecords into two foster twin data pages. New pointers are added to the parent data page ofthe split data pages to indicate the new parent child relationship between the parent datapage and the foster twin data pages. The old data page can be retired by adding a moved-bit and removing the old pointers from the parent data page to guide concurrent transactionand prevent future transactions.,*,2018,*
Hash index,*,Abstract Example implementations disclosed herein can be used to build; maintain; and usea hash table distributed across the plurality multiple nodes in a multi-node computingsystem. The hash table can include data pages associated by corresponding pointersaccording to a tree data structure. The data pages include leaf data pages. Each leaf datapage can be associated with a corresponding hash value and include a tag bitmap. When atransaction associated with a key is executed; a hash value and a tag value are generatedbased on the key. The leaf data pages can be searched using the hash value. A probabilitythat a leaf data page includes the key can be determined based on a comparison tag valuewith the tag bitmap.,*,2018,*
Read only bufferpool,*,Abstract Example implementations disclosed herein include techniques for a ready onlybufferpool for use in local nodes of a multi-node computing system. Read only transactionsexecuted by a processor can reference a ready only bufferpool resident in a VRAM on thesame node. If the desired data page is in the bufferpool the transaction can immediatelyread data records from the cached data pages. If the desired data page is not in thebufferpool; then the transaction can cause a copy of a corresponding data page in asecondary memory to be installed in the bufferpool. The bufferpool can include more thanone copy of a data page simultaneously to handle and prevent cache line misses. Datapage are dropped from the bufferpool based on an incrementing per data page counter.,*,2018,*
Transactional key-value store,*,Abstract Example implementations herein can be used to build; maintain; and accessdatabases built database in multi-core computing systems with large VRAM and hugeNVRAM. The database with optimistic concurrency control can be built on a transactionalkey-value data store that includes logically equivalent data pages stored in both VRAM andVRAM. Data records in volatile data pages in the VRAM represent the most recent version ofthe data. Data records in the NVRAM immutable and are organized in a stratified compositesnapshot. A distributed log gleaner process is used to process entries corresponding totransactions on the volatile data pages and construct the snapshot. The log gleaner sorts thelog entries by epoch; key range; and most recent use to partition the snapshot acrossmultiple nodes.,*,2017,*
Heap data structure,*,Abstract Example implementations disclosed herein include techniques for systems;methods; and devices for a heap data structure organized into linked-lists of epoch datapages on a per-core basis in a multi-core multi-node computing system to handle manyconcurrent transactions.,*,2017,*
Tree data structure,*,A method of implementing a tree data structure comprises creating a parent and childrelationship between a first node and a second node; in which the first node and secondnode are at the same hierarchical level of the tree data structure; and maintaining only oneincoming pointer for each of the nodes in the tree data structure at all times. A tree datastructure in which each node in the tree data structure has a single incoming pointer; and inwhich the tree data structure comprises a pointer directed to a local overflow node from anode at the same hierarchical level as the local overflow node.,*,2017,*
Per-node custom code engine for distributed query processing,*,Distributed query processing is often performed by a set of nodes that apply MapReduce toa data set and materialize partial results to storage; which are then aggregated to producethe query result. However; this architecture requires a preconfigured set of database nodes;can only fulfill queries that utilize MapReduce processing; and may be slowed down bymaterializing partial results to storage. Instead; distributed query processing can beachieved by choosing a node for various portions of the query; and generating customizedcode for the node that only performs the query portion that is allocated to the node. The nodeexecutes the code to perform the query portion; and rather than materializing partial resultsto storage; streams intermediate query results to a next selected node in the distributedquery. Nodes selection may be involve matching the details of the query portion with the …,*,2017,*
Structuring page images in a memory,*,Approaches for structuring a plurality of page images in-memory are described in variousexamples of the present disclosure. In one example; a unique page identifier provided withina reference page image is identified. The unique page identifier is associated with a targetpage image stored in-memory. Once identified; the page identifier associated with the targetpage image is replaced with a location specific identifier of the target page image; whereinthe location specific identifier is based on an in-memory location of the target page image.,*,2017,*
Methods and systems for a deadlock resolution engine,*,In at least some examples; a system may include a processor core and a non-transitorycomputer-readable memory in communication with the processor core. The non-transitorycomputer-readable memory may store a deadlock resolution engine to resolve a deadlockcondition based on an abort shortest pipeline policy.,*,2014,*
Optimizing Index Deployment Order for Evolving OLAP (Extended Version),Hideaki Kimura; Carleton Coffrin; Alexander Rasin; Stanley B Zdonik,Abstract: Query workloads and database schemas in OLAP applications are becomingincreasingly complex. Moreover; the queries and the schemas have to continually\textit{evolve} to address business requirements. During such repetitive transitions; the\textit{order} of index deployment has to be considered while designing the physical schemassuch as indexes and MVs. An effective index deployment ordering can produce (1) a promptquery runtime improvement and (2) a reduced total deployment time. Both of these areessential qualities of design tools for quickly evolving databases; but optimizing the problemis challenging because of complex index interactions and a factorial number of possiblesolutions.,arXiv preprint arXiv:1107.3606,2011,*
Janus: Transactional Processing of Navigational and Analytical Graph Queries on Many-core Servers,Hideaki Kimura; Alkis Simitsis; Kevin Wilkinson,ABSTRACT Existing scale-up graph engines are tuned for either short; navigationalrequests (eg; Nearest-Neighbor) or longer; analytics requests (eg; PageRank). However;they do not have good performance for both workloads running concurrently. We presentJanus; a scale-up graph engine architected for modern; many-core servers with largememory. Janus has excellent scale-up performance on navigational requests; on analyticsrequests; and on a mixed workload running concurrently both navigational and analyticsrequests.,*,*,*
