Lowering the overhead of nonblocking software transactional memory,Virendra J Marathe; Michael F Spear; Christopher Heriot; Athul Acharya; David Eisenstat; William N Scherer III; Michael L Scott,Abstract Recent years have seen the development of several different systems for softwaretransactional memory (STM). Most either employ locks in the underlying implementation ordepend on thread-safe general-purpose garbage collection to collect stale data andmetadata. We consider the design of low-overhead; obstruction-free software transactionalmemory for non-garbage-collected languages. Our design eliminates dynamic allocation oftransactional metadata and co-locates data that are separate in other systems; therebyreducing the expected number of cache misses on the common-case code path; whilepreserving nonblocking progress and requiring no atomic instructions other than single-word load; store; and compare-and-swap (or load-linked/store-conditional). We also employa simple; epoch-based storage management system and introduce a novel conservative …,Workshop on Languages; Compilers; and Hardware Support for Transactional Computing (TRANSACT),2006,315
NOrec: streamlining STM by abolishing ownership records,Luke Dalessandro; Michael F Spear; Michael L Scott,Abstract Drawing inspiration from several previous projects; we present an ownership-record-free software transactional memory (STM) system that combines extremely lowoverhead with unusually clean semantics. While unlikely to scale to hundreds of activethreads; this" NOrec" system offers many appealing features: very low fast-path latency--aslow as any system we know of that admits concurrent updates; publication and privatizationsafety; livelock freedom; a small; constant amount of global metadata; and full compatibilitywith existing data structure layouts; no false conflicts due to hash collisions; compatibilitywith both managed and unmanaged languages; and both static and dynamic compilation;and easy acccommodation of closed nesting; inevitable (irrevocable) transactions; andstarvation avoidance mechanisms. To the best of our knowledge; no extant STM system …,ACM Sigplan Notices,2010,289
Privatization techniques for software transactional memory,Michael F Spear; Virendra J Marathe; Luke Dalessandro; Michael L Scott,Transactional memory (TM) allows the programmer to encapsulate arbitrary memoryoperations into a single transaction that appears to be atomic and isolated from othertransactions. In addition; TM systems must generally address the possibility that shared datamay be accessed outside a transaction. The strong isolation model [1; 3] guarantees thattransactions are isolated from nontransactional (“naked”) loads and stores; as well as othertransactions. Due to the perceived high overheads for achieving strong isolation in softwareTM systems (STMs); the so-called weak isolation model; which guarantees isolation onlyamong transactions; is also considered by some as an acceptable alternative. Under weakisolation; a simple programming model is single lock atomicity:“a program executes as if alltransactions were protected by a single; program-wide mutual exclusion lock”[3; pp. 20] …,Proceedings of the twenty-sixth annual ACM symposium on Principles of distributed computing,2007,168
Conflict detection and validation strategies for software transactional memory,Michael F Spear; Virendra J Marathe; William N Scherer; Michael L Scott,Abstract In a software transactional memory (STM) system; conflict detection is the problemof determining when two transactions cannot both safely commit. Validation is the relatedproblem of ensuring that a transaction never views inconsistent data; which might potentiallycause a doomed transaction to exhibit irreversible; externally visible side effects. Existingmechanisms for conflict detection vary greatly in their degree of speculation and theirrelative treatment of read-write and write-write conflicts. Validation; for its part; appears to bea dominant factor—perhaps the dominant factor—in the cost of complex transactions. Wepresent the most comprehensive study to date of conflict detection strategies; characterizingthe tradeoffs among them and identifying the ones that perform the best for various types ofworkload. In the process we introduce a lightweight heuristic mechanism—the global …,International Symposium on Distributed Computing,2006,154
A comprehensive strategy for contention management in software transactional memory,Michael F Spear; Luke Dalessandro; Virendra J Marathe; Michael L Scott,Abstract In Software Transactional Memory (STM); contention management refers to themechanisms used to ensure forward progress--to avoid livelock and starvation; and topromote throughput and fairness. Unfortunately; most past approaches to contentionmanagement were designed for obstruction-free STM frameworks; and impose significantconstant-time overheads. Priority-based approaches in particular typically require that readsbe visible to all transactions; an expensive property that is not easy to support in most STMsystems. In this paper we present a comprehensive strategy for contention management viafair resolution of conflicts in an STM with invisible reads. Our strategy depends on (1) lazyacquisition of ownership;(2) extendable timestamps; and (3) an efficient way to capture bothpriority and conflicts. We introduce two mechanisms--one using Bloom filters; the other …,ACM Sigplan Notices,2009,153
RingSTM: scalable transactions with a single atomic instruction,Michael F Spear; Maged M Michael; Christoph von Praun,Abstract Existing Software Transactional Memory (STM) designs attach metadata to rangesof shared memory; subsequent runtime instructions read and update this metadata in orderto ensure that an in-flight transaction's reads and writes remain correct. The overhead ofmetadata manipulation and inspection is linear in the number of reads and writes performedby a transaction; and involves expensive read-modify-write instructions; resulting insubstantial overheads. We consider a novel approach to STM; in which transactionsrepresent their read and write sets as Bloom filters; and transactions commit by enqueuing aBloom filter onto a global list. Using this approach; our RingSTM system requires at mostone read-modify-write operation for any transaction; and incurs validation overhead linearnot in transaction size; but in the number of concurrent writers who commit. Furthermore …,Proceedings of the twentieth annual symposium on Parallelism in algorithms and architectures,2008,146
Hybrid norec: A case study in the effectiveness of best effort hardware transactional memory,Luke Dalessandro; Francois Carouge; Sean White; Yossi Lev; Mark Moir; Michael L Scott; Michael F Spear,Abstract Transactional memory (TM) is a promising synchronization mechanism for the nextgeneration of multicore processors. Best-effort Hardware Transactional Memory (HTM)designs; such as Sun's prototype Rock processor and AMD's proposed AdvancedSynchronization Facility (ASF); can efficiently execute many transactions; but abort in somecases due to various limitations. Hybrid TM systems can use a compatible software TM(STM) in such cases. We introduce a family of hybrid TMs built using the recent NOrec STMalgorithm that; unlike existing hybrid approaches; provide both low overhead on hardwaretransactions and concurrent execution of hardware and software transactions. We evaluateimplementations for Rock and ASF; exploring how the differing HTM designs affectoptimization choices. Our investigation yields valuable input for designers of future best …,ACM SIGARCH Computer Architecture News,2011,140
An integrated hardware-software approach to flexible transactional memory,Arrvindh Shriraman; Michael F Spear; Hemayet Hossain; Virendra J Marathe; Sandhya Dwarkadas; Michael L Scott,Abstract There has been considerable recent interest in both hardware andsoftwaretransactional memory (TM). We present an intermediateapproach; in which hardware servesto accelerate a TM implementation controlled fundamentally by software. Specifically; wedescribe an alert on update mechanism (AOU) that allows a thread to receive fast;asynchronous notification when previously-identified lines are written by other threads; anda programmable data isolation mechanism (PDI) that allows a thread to hide its speculativewrites from other threads; ignoring conflicts; until software decides to make them visible.These mechanisms reduce bookkeeping; validation; and copying overheads withoutconstraining software policy on a host of design decisions. We have used AOU and PDI toimplement a hardwareacceleratedsoftware transactional memory system we call RTM …,ACM SIGARCH Computer Architecture News,2007,140
Hardware acceleration of software transactional memory,Arrvindh Shriraman; Virendra J Marathe; Sandhya Dwarkadas; Michael L Scott; David Eisenstat; Christopher Heriot; William N Scherer III; Michael F Spear,Abstract Transactional memory (TM) systems seek to increase scalability; reduceprogramming complexity; and overcome the various semantic problems associated withlocks. Software TM proposals run on stock processors and provide substantial flexibility inpolicy; but incur significant overhead for data versioning and validation in the face ofconflicting transactions. Hardware TM proposals have the advantage of speed; but aretypically highly ambitious; embed significant amounts of policy in silicon; and provide noclear migration path for software that must also run on legacy machines. We advocate anintermediate approach; in which hardware is used to accelerate a TM implementationcontrolled fundamentally by software. We present a system; RTM; that embodies thisapproach. It consists of a novel transactional MESI (TMESI) protocol and accompanying …,ACM SIGPLAN Workshop on Transactional Computing; Ottawa; ON; Canada,2006,75
Scalable techniques for transparent privatization in software transactional memory,Virendra J Marathe; Michael F Spear; Michael L Scott,We address the recently recognized privatization problem in software transactional memory(STM) runtimes; and introduce the notion of partially visible reads (PVRs) to heuristicallyreduce the overhead of transparent privatization. Specifically; PVRs avoid the need for a"privatization fence" in the absence of conflict with concurrent readers. We present severaltechniques to trade off the cost of enforcing partial visibility with the precision of conflictdetection. We also consider certain special-case variants of our approach; eg; forpredominantly read-only workloads. We compare our implementations to prior techniqueson a multicore Niagara1 system using a variety of artificial workloads. Our results suggestthat while no one technique performs best in all cases; a dynamic hybrid of PVRs and strictin-order commits is stable and reasonably fast across a wide range of load parameters. At …,Parallel Processing; 2008. ICPP'08. 37th International Conference on,2008,71
Delaunay triangulation with transactions and barriers,Michael L Scott; Michael F Spear; Luke Dalessandro; Virendra J Marathe,Transactional memory has been widely hailed as a simpler alternative to locks inmultithreaded programs; but few nontrivial transactional programs are currently available.We describe an open-source implementation of Delaunay triangulation that usestransactions as one component of a larger parallelization strategy. The code is written inC++; for use with the RSTM software transactional memory library (also open source). Itemploys one of the fastest known sequential algorithms to triangulate geometricallypartitioned regions in parallel; it then employs alternating; barrier-separated phases oftransactional and partitioned work to stitch those regions together. Experiments onmultiprocessor and multicore machines confirm excellent single-thread performance andgood speedup with increasing thread count. Since execution time is dominated by …,Workload Characterization; 2007. IISWC 2007. IEEE 10th International Symposium on,2007,65
Implementing and exploiting inevitability in software transactional memory,Michael F Spear; Michael Silverman; Luke Dalessandro; Maged M Michael; Michael L Scott,Transactional Memory (TM) takes responsibility for concurrent; atomic execution of labeledregions of code; freeing the programmer from the need to manage locks. Typicalimplementations rely on speculation and rollback; but this creates problems for irreversibleoperations like interactive I/OA widely assumed solution allows a transaction to operate inan inevitable mode that excludes all other transactions and is guaranteed to complete; butthis approach does not scale. This paper explores a richer set of alternatives for softwareTM; and demonstrates that it is possible for an inevitable transaction to run in parallel with(non-conflicting) non-inevitable transactions; without introducing significant overhead in thenon-inevitable case. We report experience with these alternatives in a graphical gameapplication. We also consider the use of inevitability to accelerate certain common-case …,Parallel Processing; 2008. ICPP'08. 37th International Conference on,2008,60
Inevitability mechanisms for software transactional memory,Michael Spear; Maged Michael; Michael Scott,Abstract Transactional Memory simplifies parallel programming by eliminating the use oflocks to protect concurrent accesses to shared memory. However; when locks are used toprovide mutual exclusion for irreversible operations (I/O; syscalls; calls to “black box”libraries); their replacement with transactions seems problematic: transactions can abort andrestart at any arbitrary point in their execution; which is unacceptable when operationsperformed during a transaction have made the intermediate state of that transaction visibleto an outside agent. Permitting at most one transaction to operate in an “inevitable” mode;where it is guaranteed to commit; is widely accepted as a solution to the irreversibilityproblem for transactions; albeit one that is not expected to scale. In this paper we explore avariety of mechanisms to support inevitability in software transactional memory. We …,3rd ACM SIGPLAN Workshop on Transactional Computing; New York; NY; USA,2008,57
Solving the starting problem: device drivers as self-describing artifacts,Michael F Spear; Tom Roeder; Orion Hodson; Galen C Hunt; Steven Levi,Abstract Run-time conflicts can affect even the most rigorously tested software systems. Areliance on execution-based testing makes it prohibitively costly to test every possibleinteraction among potentially thousands of programs with complex configurations. In order toreduce configuration problems; detect developer errors; and reduce developer effort; wehave created a new first class operating system abstraction; the application abstraction;which enables both online and offline reasoning about programs and their configurationrequirements. We have implemented a subset of the application abstraction for devicedrivers in the Singularity operating system. Programmers use the application abstraction byplacing declarative statements about hardware and communication requirements withintheir code. Our design enables Singularity to learn the input/output and interprocess …,ACM SIGOPS Operating Systems Review,2006,47
Ordering-based semantics for software transactional memory,Michael F Spear; Luke Dalessandro; Virendra J Marathe; Michael L Scott,Abstract It has been widely suggested that memory transactions should behave as if theyacquired and released a single global lock. Unfortunately; this behavior can be expensive toachieve; particularly when—as in the natural publication/privatization idiom—the same dataare accessed both transactionally and nontransactionally. To avoid overhead; we proposeselective strict serializability (SSS) semantics; in which transactions have a global totalorder; but nontransactional accesses are globally ordered only with respect to explicitlymarked transactions. Our definition of SSS formally characterizes the permissible behaviorsof an STM system without recourse to locks. If all transactions are marked; then SSS; single-lock semantics; and database-style strict serializability are equivalent. We evaluate severalSSS implementations in the context of a TL2-like STM system. We also evaluate a weaker …,International Conference on Principles of Distributed Systems,2008,46
Transactional mutex locks,Luke Dalessandro; Dave Dice; Michael Scott; Nir Shavit; Michael Spear,Abstract Mutual exclusion (mutex) locks limit concurrency but offer low single-thread latency.Software transactional memory (STM) typically has much higher latency; but scales well. Wepresent transactional mutex locks (TML); which attempt to achieve the best of both worlds forread-dominated workloads. We also propose compiler optimizations that reduce the latencyof TML to within a small fraction of mutex overheads. Our evaluation of TML; usingmicrobenchmarks on the x86 and SPARC architectures; is promising. Using optimizedspinlocks and the TL2 STM algorithm as baselines; we find that TML provides the lowlatency of locks at low thread levels; and the scalability of STM for read-dominatedworkloads. These results suggest that TML is a good reference implementation to use whenevaluating STM algorithms; and that TML is a viable alternative to mutex locks for a …,European Conference on Parallel Processing,2010,45
Capabilities and limitations of library-based software transactional memory in C++,Luke Dalessandro; Virendra J Marathe; Michael F Spear; Michael L Scott,Abstract Like many past extensions to user programming models; transactions can be addedto the programming language or implemented in a library using existing language features.We describe a library-based transactional memory API for C++. Designed to address thelimitations of an earlier API with similar functionality; the new interface leverages macros;exceptions; multiple inheritance; generics (templates); and overloading of operators(including pointer dereference) in an attempt to minimize syntactic clutter; admit a widevariety of back-end implementations; avoid arbitrary restrictions on otherwise valid languageconstructs; enable privatization; catch as many programmer errors as possible; and providesemantics that “seem natural” to C++ programmers. Having used our API to constructseveral small and one large application; we conclude that while the interface is a …,Proceedings of the 2nd ACM SIGPLAN Workshop on Transactional Computing,2007,45
Configuration of isolated extensions and device drivers,*,In some implementations; the operations of a software system may include the execution ofuntrusted device drivers. The execution of an untrusted device driver may be initiated whenan untrusted device driver that is a set of executable instructions is obtained. A computingresource for the execution of the device driver may be further determined from a device-driver manifest of the untrusted device driver. Computing resources may include one ormore of a hardware resource; a memory; an input/output port; an interrupt request line; andan inter-process communication channel. Trusted local access objects may be used by theuntrusted device driver to access the computing resources.,*,2011,44
Lightweight; robust adaptivity for software transactional memory,Michael F Spear,Abstract When a program uses Software TransactionalMemory (STM) to synchronizeaccesses to shared memory; the performance often depends on which STM implementationis used. Implementation vary greatly in their underlying mechanisms; in the features theyprovide; and in the assumptions they make about the common case. Consequently; the bestchoice of algorithm is workload-dependent. Worse yet; for workload composed of multiplephases of execution; the" best choice of implementation may change during execution. Wepresent a low-overhead system for adapting between STM implementations. Like previouswork; our system enable adaptivity between different parameterizations of a given algorithm;and it allows adapting between the use of transactions and coarse-grained locks. Inaddition; we support dynamic switching between fundamentally different STM …,Proceedings of the twenty-second annual ACM symposium on Parallelism in algorithms and architectures,2010,43
Transactionalizing legacy code: An experience report using GCC and memcached,Wenjia Ruan; Trilok Vyas; Yujie Liu; Michael Spear,Abstract The addition of transactional memory (TM) support to existing languages providesthe opportunity to create new soft-ware from scratch using transactions; and also to simplifyor extend legacy code by replacing existing synchronization with language-leveltransactions. In this paper; we describe our experiences transactionalizing the memcachedapplication through the use of the GCC implementation of the Draft C++ TM Specification.We present experiences and recommendations that we hope will guide the effort to integrateTM into languages; and that may also contribute to the growing collective knowledge abouthow programmers can begin to exploit TM in existing production-quality software.,ACM SIGPLAN Notices,2014,40
A transactional memory with automatic performance tuning,Qingping Wang; Sameer Kulkarni; John Cavazos; Michael Spear,Abstract A significant obstacle to the acceptance of transactional memory (TM) in real-worldparallel programs is the abundance of substantially different TM algorithms. Each TMalgorithm appears well-suited to certain workload characteristics; but the best choice ofalgorithm is sensitive to program inputs; available cores; and program phases. Furthermore;operating system and hardware characteristics can affect which algorithm is best; withtradeoffs changing across iterations of a single ISA. This paper introduces methods forconstructing policies to dynamically select the most appropriate TM algorithm based onstatic and dynamic information. We leverage intraprocedural static analysis to create a staticprofile of the application. We also introduce a low-overhead framework for dynamic profilingof a running transactional application. Armed with these complementary descriptions of a …,ACM Transactions on Architecture and Code Optimization (TACO),2012,40
Managing concurrent transactions using bloom filters,*,A computer-implemented method for managing concurrent transactions includes recordinglocations written by a first transaction in a first Bloom filter; recording locations to be read bya second transaction in a second Bloom filter; and performing one of a cancellation or acommission of the second transaction based on an intersection of the first Bloom filter andthe second Bloom filter.,*,2009,37
Managing concurrent transactions using bloom filters,*,A computer-implemented method for managing concurrent transactions includes recordinglocations written by a first transaction in a first Bloom filter; recording locations to be read bya second transaction in a second Bloom filter; and performing one of a cancellation or acommission of the second transaction based on an intersection of the first Bloom filter andthe second Bloom filter.,*,2009,37
MANAGING CONCURRENT TRANSACTIONS USING BLOOM FILTERS,*,A computer-implemented method for managing concurrent transactions includes recordinglocations written by a first transaction in a first Bloom filter; recording locations to be read bya second transaction in a second Bloom filter; and performing one of a cancellation or acommission of the second transaction based on an intersection of the first Bloom filter andthe second Bloom filter.,*,2008,37
STAMP need not be considered harmful,Wenjia Ruan; Yujie Liu; Michael Spear,*,Ninth ACM SIGPLAN Workshop on Transactional Computing,2014,34
System and method for hardware acceleration of a software transactional memory,*,In a transactional memory technique; hardware serves simply to optimize the performance oftransactions that are controlled fundamentally by software. The hardware support reducesthe overhead of common TM tasks—conflict detection; validation; and data isolation—forcommon-case bounded transactions. Software control preserves policy flexibility andsupports transactions unbounded in space and in time. The hardware includes 1) an alert-on-update mechanism for fast software-controlled conflict detection; and 2) programmabledata isolation; allowing potentially conflicting readers and writers to proceed concurrentlyunder software control.,*,2012,32
Compiler and runtime techniques for software transactional memory optimization,Peng Wu; Maged M Michael; Christoph von Praun; Takuya Nakaike; Rajesh Bordawekar; Harold W Cain; Calin Cascaval; Siddhartha Chatterjee; Stefanie Chiras; Rui Hou; Mark Mergen; Xiaowei Shen; Michael F Spear; Hua Yong Wang; Kun Wang,Abstract Software transactional memory (STM) systems are an attractive environment toevaluate optimistic concurrency. We describe our experience of supporting and optimizingan STM system at both the managed runtime and compiler levels. We describe the designpolicies of our STM system and the statistics collected by the runtime to identify performancebottlenecks and guide tuning decisions. We present an initial work on supporting automaticinstrumentation of the STM primitives for C/C++ and Java programs in the IBM XL compilerand J9 Java virtual machine. We evaluate and discuss the performance of severaltransactional programs running on our system. Copyright© 2008 John Wiley & Sons; Ltd.,Concurrency and Computation: Practice and Experience,2009,28
Nonblocking transactions without indirection using alert-on-update,Michael F Spear; Arrvindh Shriraman; Luke Dalessandro; Sandhya Dwarkadas; Michael L Scott,Abstract Nonblocking implementations of software transactional memory (STM) typicallyimpose an extra level of indirection when accessing an object; some researchers haveclaimed that the cost of this indirection outweighs the semantic advantages of nonblockingprogress guarantees. We consider this claim in the context of a simple hardware assist; alert-on-update (AOU); which allows a thread to request immediate notification if specified line (s)are replaced or invalidated in its cache. We show that even a single AOU line allows us toconstruct a simple; nonblocking STM system without extra indirection. At the same time; weobserve that per-load validation operations; required for intra-object consistency in both thenew system and in lock-based (blocking) STM; at least partially negate the resultingperformance gain. Moreover; inter-object consistency checks; also required in both kinds …,Proceedings of the nineteenth annual ACM symposium on Parallel algorithms and architectures,2007,27
Reducing memory ordering overheads in software transactional memory,Michael F Spear; Maged M Michael; Michael L Scott; Peng Wu,Abstract Most research into high-performance software transactional memory (STM)assumes that transactions will run on a processor with a relatively strict memory model; suchas Total Store Ordering (TSO). To execute these algorithms correctly on processors withrelaxed memory models; explicit fence instructions may be required on every transactionalaccess; and neither the processor nor the compiler may be able to safely reordertransactional reads. The overheads of fence instructions and read serialization are asignificant but unstudied source of latency for STM; with impact on the tradeoffs amongdifferent STM systems and on the optimizations that may be possible for any given system.Straightforward ports of STM runtimes from strict to relaxed machines may fail to realize thelatter's performance potential. We explore the implementation of STM for machines with …,Proceedings of the 7th annual IEEE/ACM International Symposium on Code Generation and Optimization,2009,26
Transactional mutex locks,Michael F Spear; Arrvindh Shriraman; Luke Dalessandro; Michael L Scott,Abstract Mutual exclusion locks limit concurrency but offer low latency. Softwaretransactional memory (STM) typically has higher latency; but scales well. In this paper wepropose transactional mutex locks (TML); which attempt to achieve the best of both worldsfor read-dominated workloads. TML has much lower latency than STM; enabling it to performcompetitively with mutexes. It also scales as well as STM when critical sections rarelyperform writes. In this paper; we describe the design of TML and evaluate its performanceusing microbenchmarks on the x86; SPARC; and POWER architectures. Our experimentsshow that while TML is not general enough to completely subsume both STM and locks; itoffers compelling performance for the targeted workloads; without performing substantiallyworse than locks when writes are frequent.,SIGPLAN Workshop on Transactional Computing,2009,26
Alert-on-update: a communication aid for shared memory multiprocessors,Michael F Spear; Arrvindh Shriraman; Hemayet Hossain; Sandhya Dwarkadas; Michael L Scott,A traditional advantage of shared-memory multiprocessors is their ability to support very fastimplicit communication: if thread A modifies location D; thread B will see the change as soonas it tries to read D; no explicit receive is required. There are times; however; when B needsto know of A's action immediately. Event-based programs and condition synchronization areobvious examples; but there are many others. Consider a program in which B reads V fromD; computes a new value V (a potentially time-consuming task); and uses compare-and-swap to install V in D only if no other thread has completed an intervening update. If somethread A has completed an update; then all of B's work subsequent to that update will bewasted. More significantly; suppose we generalize the notion of atomic update to implementsoftware transactional memory (STM)[4]. Now A may not only force B to back out (abort) …,Proceedings of the 12th ACM SIGPLAN symposium on Principles and practice of parallel programming,2007,24
Fastpath speculative parallelization,Michael F Spear; Kirk Kelsey; Tongxin Bai; Luke Dalessandro; Michael L Scott; Chen Ding; Peng Wu,Abstract We describe Fastpath; a system for speculative parallelization of sequentialprograms on conventional multicore processors. Our system distinguishes between the leadthread; which executes at almost-native speed; and speculative threads; which executesomewhat slower. This allows us to achieve nontrivial speedup; even on two-core machines.We present a mathematical model of potential speedup; parameterized by applicationcharacteristics and implementation constants. We also present preliminary results gleanedfrom two different Fastpath implementations; each derived from an implementation ofsoftware transactional memory.,International Workshop on Languages and Compilers for Parallel Computing,2009,22
Dynamic-sized nonblocking hash tables,Yujie Liu; Kunlong Zhang; Michael Spear,Abstract This paper presents nonblocking hash table algorithms that support resizing in bothdirections: shrinking and growing. The heart of the table is a freezable set abstraction; whichgreatly simplifies the task of moving elements among buckets during a resize. Furthermore;the freezable set abstraction makes possible the use of highly optimized implementations ofindividual buckets; including implementations in which a single flat array is used for eachbucket; which improves cache locality. We present lock-free and wait-free variants of ourhash table; to include fast adaptive wait-free variants based on the Fastpath/Slowpathmethodology. In evaluation on SPARC and x86 architectures; we find that performance ofour lock-free implementation is consistently better than the current state-of-the-art split-ordered list; and that performance for the adaptive wait-free algorithm is compelling …,Proceedings of the 2014 ACM symposium on Principles of distributed computing,2014,16
Transaction-friendly condition variables,Chao Wang; Yujie Liu; Michael Spear,Abstract Recent microprocessors and compilers have added support for transactionalmemory (TM). While state-of-the-art TM systems allow the replacement of lock-based criticalsections with scalable; optimistic transactions; there is not yet an acceptable mechanism forsupporting the use of condition variables in transactions. We introduce a newimplementation of condition variables; which uses transactions internally; which can be usedfrom within both transactions and lock-based critical sections; and which is compatible withexisting C/C++ interfaces for condition synchronization. By moving most of the mechanismfor condition synchronization into user-space; our condition variables have low overheadand permit flexible interfaces that can avoid some of the pitfalls of traditional conditionvariables. Performance evaluation on an unmodified PARSEC benchmark suite shows …,Proceedings of the 26th ACM symposium on Parallelism in algorithms and architectures,2014,15
Toxic transactions,Yujie Liu; Michael Spear,Abstract In Transactional Memory workloads; conflicts among transactions necessitate thatsome transactions either block; or else abort. The more common approach; aborting; isunder-studied. Much effort has explored the use of schedulers and gatekeepers when theglobal abort rate is high. Handling short spikes in the abort rate; especially due to a singletransaction with a high likelihood of conflict; is less well understood. We refer to suchtransactions as “toxic”; and suggest that they be prioritized; to prevent repeated aborts. Tothis end; we propose an Hourglass Contention Manager; which blocks some transactions attheir begin point whenever a toxic transaction is detected. We show this mechanism to offerlow overhead; and argue that it is an attractive alternative to existing contentionmanagement policies in transactional memory.,*,2011,14
Boosting timestamp-based transactional memory by exploiting hardware cycle counters,Wenjia Ruan; Yujie Liu; Michael Spear,Abstract Time-based transactional memories typically rely on a shared memory counter toensure consistency. Unfortunately; such a counter can become a bottleneck. In this article;we identify properties of hardware cycle counters that allow their use in place of a sharedmemory counter. We then devise algorithms that exploit the x86 cycle counter to enablebottleneck-free transactional memory runtime systems. We also consider the impact ofprivatization safety and hardware ordering constraints on the correctness; performance; andgenerality of our algorithms.,ACM Transactions on Architecture and Code Optimization (TACO),2013,13
Towards applying machine learning to adaptive transactional memory,Qingping Wang; Sameer Kulkarni; John V Cavazos; Michael Spear,Abstract There is tremendous diversity among the published algorithms for implementingTransactional Memory (TM). Each of these algorithms appears to be well suited to certainworkloads and architectures. However; for programs that operate in distinct phases; exhibitinput-dependent behavior; or must run on many different classes of machine; the bestalgorithm cannot be selected before the program actually runs. We introduce a mechanismfor dynamic profiling of a running transactional program; and show how the profile can beused with machine learning techniques to select a TM implementation at run-time. Ourpreliminary results on the STAMP benchmark suite show good performance; providing abaseline for future research into adaptivity mechanisms for TM.,Proceedings of the 6th ACM SIGPLAN Workshop on Transactional Computing,2011,13
Reading mobile games throughout the curriculum,Jennifer Bayzick; Bradley Askins; Sharon Kalafut; Michael Spear,Abstract We introduce ALE; a new framework for writing games for the Android platform. Theprimary motivation behind ALE is to emphasize reading code before writing it. Beginnersread game code to learn how levels can be made; and advanced users read the code ofALE itself to learn how to create useful and extensible libraries. To date; roughly 200students at our university have used ALE; ranging from first-semester engineeringundergraduates through Masters students. ALE has proven useful in teaching non-majorsabout CS; in making introductory CS programming courses more exciting; and inencouraging creativity; entrepreneurship; and good program design in upper-level electives.Based on these experiences; we encourage educators at all levels to consider using ALE toimprove students' ability to learn by reading code.,Proceeding of the 44th ACM technical symposium on Computer science education,2013,11
Lowering the overhead of nonblocking software transactional memory. revised; University of Rochester,VJ Marathe; MF Spear; C Heriot; A Acharya; D Eisenstat; WN Scherer III; ML Scott,*,Computer Science Department,2006,11
Mounds: Array-based concurrent priority queues,Yujie Liu; Michael Spear,This paper introduces a concurrent data structure called the mound. The mound is a rootedtree of sorted lists that relies on randomization for balance. It supports O (log (log (N))) insertand O (log (N)) extract Min operations; making it suitable for use as a priority queue. Wepresent two mound algorithms: the first achieves lock freedom via the use of a pure-softwaredouble-compare-and-swap (DCAS); and the second uses fine grained locks. Moundsperform well in practice; and support novel operations that we expect to be useful in parallelapplications; such as extract Many and probabilistic extract Min.,Parallel Processing (ICPP); 2012 41st International Conference on,2012,10
A lock-free; array-based priority queue,Yujie Liu; Michael Spear,Priority queues are useful in scheduling; discrete event simulation; networking (eg; routingand real-time bandwidth management); graph algorithms (eg; Dijkstra's algorithm); andartificial intelligence (eg; A∗ search). In these and other applications; not only is it crucial forpriority queues to have low latency; but they must also offer good scalability and guaranteeprogress. Furthermore; the insert and extractMin operations are expected to have no worsethan O (log (N)) complexity. In practice; this has focused implementation on heaps [1; Ch.6][4] and skip lists [6]. This paper introduces a new lock-free; linearizable [3] priority queue;called the mound. A mound is a tree of sorted lists. Mounds employ randomization whenchoosing a starting leaf for an insert; which avoids the need for insertions to contend for amound-wide counter; but introduces the possibility that a mound will have “empty” nodes …,ACM SIGPLAN Notices,2012,10
Practical non-blocking unordered lists,Kunlong Zhang; Yujiao Zhao; Yajun Yang; Yujie Liu; Michael Spear,Abstract This paper introduces new lock-free and wait-free unordered linked list algorithms.The composition of these algorithms according to the fast-path-slow-path methodology; arecently devised approach to creating fast wait-free data structures; is nontrivial; suggestinglimitations to the applicability of the fast-path-slow-path methodology. The list algorithmsintroduced in this paper are shown to scale well across a variety of benchmarks; makingthem suitable for use both as standalone lists; and as the foundation for wait-free stacks andnon-resizable hash tables.,International Symposium on Distributed Computing,2013,9
Transactional read-modify-write without aborts,Wenjia Ruan; Yujie Liu; Michael Spear,Abstract Language-level transactions are said to provide “atomicity;” implying that the orderof operations within a transaction should be invisible to concurrent transactions and thus thatindependent operations within a transaction should be safe to execute in any order. In thisarticle; we present a mechanism for dynamically reordering memory operations within atransaction so that read-modify-write operations on highly contended locations can bedelayed until the very end of the transaction. When integrated with traditional transactionalconflict detection mechanisms; our approach reduces aborts on hot memory locations; suchas statistics counters; thereby improving throughput and reducing wasted work. We presentthree algorithms for delaying highly contended read-modify-write operations withintransactions; and we evaluate their impact on throughput for eager and lazy transactional …,ACM Transactions on Architecture and Code Optimization (TACO),2015,8
Transactional memory support for C+,Victor Luchangco; Michael Wong; Hans Boehm; Justin Gottschlich; Jens Maurer; Paul McKenney; Maged Michael; Mark Moir; Torvald Riegel; Michael Scott; Tatiana Shpeisman; Michael Spear,Transactional memory supports a programming style that is intended to facilitate parallelexecution with a comparatively gentle learning curve. This document describes a proposaldeveloped by SG5 to introduce transactional constructs into C++ as a TechnicalSpecification. It is based in part on the Draft Specification for Transactional Constructs inC++(Version 1.1) published by the Transactional Memory Specification Drafting Group inFebruary 2012. This proposal represents a pragmatic basic set of features; and omits orsimplifies a number of controversial or complicated features from the Draft Specification. Ourgoal has been to focus the SG5's efforts towards a basic set of features that is useful and cansupport progress towards possible inclusion in the C++ standard. Reflecting this goal; for thefirst time; we present precise wording changes relative to the Working Draft of the C++ …,*,2014,8
Transactional acceleration of concurrent data structures,Yujie Liu; Tingzhe Zhou; Michael Spear,Abstract Concurrent data structures are a fundamental building block for scalable multi-threaded programs. While Transactional Memory (TM) was originally conceived as amechanism for simplifying the creation of concurrent data structures; modern hardware TMsystems lack the progress properties needed to completely obviate traditional techniques fordesigning concurrent data structures; especially those requiring nonblocking progressguarantees. In this paper; we introduce the Prefix Transaction Optimization (PTO) techniquefor employing hardware TM to accelerate existing concurrent data structures. Our techniqueconsists of three stages: the creation of a prefix transaction; the mechanical optimization ofthe prefix transaction; and then algorithm-specific optimizations to further improveperformance. We apply PTO to five nonblocking data structures; and observe speedups of …,Proceedings of the 27th ACM symposium on Parallelism in Algorithms and Architectures,2015,7
Delegation and nesting in best-effort hardware transactional memory,Yujie Liu; Stephan Diestelhorst; Michael Spear,Abstract The guiding design principle behind best-effort hardware transactional memory(BEHTM) is simplicity of implementation and verification. Only minimal modifications to thebase processor architecture are allowed; thereby reducing the burden of verification andlong-term support. In exchange; the hardware can support only relatively simple multiwordatomic operations; and must fall back to a software run-time for any operation that exceedsthe abilities of the hardware. This paper demonstrates that BEHTM simplicity does notprohibit advanced and complex transactional behaviors. We exploit support for immediatenon-transactional stores in the AMD Advanced Synchronization Facility to build amechanism for communication among transactions. While our system allows arbitrarycommunication patterns; we focus on a design point where each transaction …,Proceedings of the twenty-fourth annual ACM symposium on Parallelism in algorithms and architectures,2012,7
Architectural support for software thread-level speculation,*,A system for thread-level speculation includes a memory system for storing a program code;a plurality of registers corresponding to one or more execution contexts; for storing sets ofmemory addresses that are accessed speculatively; and a plurality of processors; eachproviding the one or more execution contexts; in communication with the memory system;wherein a processor of the plurality of processors executes the program code to implementmethod steps of dividing a program into a plurality of epochs to be executed in parallel bythe system; wherein one of the epochs is executed non-speculatively and the other epochsare executed speculatively; determining a current epoch to be executed on an executioncontext; encoding addresses read during execution of the current epoch; encodingaddresses written during execution of predecessor epochs of the current epoch; and …,*,2009,7
Mindicators: A scalable approach to quiescence,Yujie Liu; Victor Luchangco; Michael Spear,We introduce the Mindicator; a new shared object that is optimized for querying the minimumvalue of a set of values proposed by several processes. A mindicator may hold at most onevalue per process. This interface is designed for use in shared memory runtime systems;such as garbage collectors; software transactional memory (TM); and operating systemkernels. We introduce linearizable and relaxed mindicator implementations; both of whichare lock-free. Our algorithms employ a tree structure; where querying the minimum elementtakes constant time; and adding and removing elements from the set does not hinderscalability. In microbenchmarks and a synthetic TM workload; we show that both providegood scalability on the x86 and SPARC platforms.,Distributed Computing Systems (ICDCS); 2013 IEEE 33rd International Conference on,2013,5
Transactional memory retry mechanisms,Michael F Spear; Andrew Sveikauskas; Michael L Scott,Software TM systems typically support condition synchronization through a retry mechanism[2]. Using retry; a transaction explicitly self aborts and deschedules itself when it detects thata precondition for its operation does not hold. The runtime then tracks the set of locationsread by the retryer; and refrains from rescheduling it until at least one location in the set hasbeen modified by another transaction. When a transaction T calls retry after readinglocations {l1... lr}; the standard implementation modifies the metadata of each location li toindicate that any transaction that subsequently writes li must wake T. After marking all suchlocations; T re-checks its validity (to avoid a timing window) and yields the processor.Though elegant and simple; this implementation has several potential drawbacks. First;explicitly marking each location li requires exclusive access to li's metadata in the cache …,Proceedings of the twenty-seventh ACM symposium on Principles of distributed computing,2008,5
TSXProf: Profiling hardware transactions,Yujie Liu; Justin Gottschlich; Gilles Pokam; Michael Spear,The availability of commercial hardware transactionalmemory (TM) systems has not yetbeen met with a rise in the numberof large-scale programs that use memory transactionsexplicitly. Asignificant impediment to the use of TM is the lack of tool support; specificallyprofilers that can identify and explain performance anomalies. In this paper; we introduce anend-to-end system that enables lowoverheadperformance profiling of large-scaletransactional programs. We present algorithms and an implementation for Intel'sHaswellprocessors. With our system; it is possible to record a transactionalprogram'sexecution with minimal overhead; and then replay it withina custom profiling tool to identifycauses of contention and aborts; down to the granularity of individual memory accesses.Evaluationshows that our algorithms have low overhead; and our tools …,Parallel Architecture and Compilation (PACT); 2015 International Conference on,2015,4
Hybrid transactional memory revisited,Wenjia Ruan; Michael Spear,Abstract Hybrid Transactional Memory (TM) uses available hardware TM resources toexecute language-level transactions; and falls back to a software TM implementation forthose transactions that cannot complete in hardware. Ideally; a hybrid TM would allowhardware and software transactions to run concurrently; but would not waste hardware TMresources on coordination between the two classes of transactions. In addition; it shouldscale well; incur little latency; offer strong safety guarantees; and provide some degree offairness. We introduce a new hybrid TM algorithm;“Hybrid Cohorts”; in which hardwaretransactions do not modify global metadata; and software transactions have extremely lowper-access overhead. The tradeoff is that hardware transactions cannot commit whilesoftware transactions are in flight. Evaluation on an 8-thread Intel Haswell CPU shows …,International Symposium on Distributed Computing,2015,4
Partitioning OWL knowledge bases for parallel reasoning,Sambhawa Priya; Yuanbo Guo; Michael Spear; Jeff Heflin,The ability to reason over large scale data and return responsive query results is widelyseen as a critical step to achieving the Semantic Web vision. We describe an approach forpartitioning OWL Lite datasets and then propose a strategy for parallel reasoning aboutconcept instances and role instances on each partition. The partitions are designed suchthat each can be reasoned on independently to find answers to each query sub goal; andwhen the results are unioned together; a complete set of results are found for that sub goal.Our partitioning approach has a polynomial worst case time complexity in the size of theknowledge base. In our current implementation; we partition semantic web datasets andexecute reasoning tasks on partitioned data in parallel on independent machines. Weimplement a master-slave architecture that distributes a given query to the slave …,Semantic Computing (ICSC); 2014 IEEE International Conference on,2014,4
On the platform specificity of STM instrumentation mechanisms,Wenjia Ruan; Yujie Liu; Chao Wang; Michael Spear,Supporting atomic blocks (eg; Transactional Memory (TM)) can have far-reaching effects onlanguage design and implementation. While much is known about the language-levelsemantics of TM and the performance of algorithms for implementing TM; little is knownabout how platform characteristics affect the manner in which a compiler should instrumentcode to achieve efficient transactional behavior. We explore the interaction betweencompiler instrumentation and the performance of transactions. Through evaluation onARM/Android; SPARC/Solaris; IA32/Linux and IA32/MacOS; we show that the compiler mustconsider the platform when determining which analyses; transformations; and optimizationsto perform. Implementation issues include how TM library code is reached; how per-threadTM metadata is stored and accessed; and how a library switches between modes of …,Code Generation and Optimization (CGO); 2013 IEEE/ACM International Symposium on,2013,4
A scalable lock-free universal construction with best effort transactional hardware,Francois Carouge; Michael Spear,Abstract The imminent arrival of best-effort transactional hardware has spurred new interestin the construction of nonblocking data structures; such as those that require atomic updatesto k words of memory (for some small value of k). Since transactional memory itself (TM) wasoriginally proposed as a universal construction for crafting scalable lock-free data structures;we explore the possibility of using this emerging transactional hardware to implement ascalable; unbounded transactional memory that is simultaneously nonblocking andcompatible with strong language-level semantics. Our results show that it is possible to usethis new hardware to build nonblocking TM systems that perform as well as their blockingcounterparts. We also find that while the construction of a lock-free TM is possible;correctness arguments are complicated by the many caveats and corner cases that are …,International Symposium on Distributed Computing,2010,4
The Mimir Approach to Transactional Output,Tingzhe Zhou; Michael Spear,Abstract In order to use transactional memory (TM) in place of locks; it is necessary to designlinguistic mechanisms that enable transactions to achieve the same outcomes as lock-basedcode. The mechanisms need not match their lock-based equivalents exactly; but mustprovide the same abilities “in spirit;” so that programmers can (perhaps with nontrivial coderewriting) achieve the same behaviors and guarantees from transactions as with locks. Inthis paper; we focus on the question of transactional output; and introduce the Mimirmethodology. Mimir employs an observation about two-phase locking and language-leveltransactional semantics to enable deferred output operations that appear to execute inisolation with respect to all concurrent transactions; but without serializing those othertransactions. The technique employs ephemeral privatization and retry-based condition …,Proceedings of the 11th ACM SIGPLAN Workshop on Transactional Computing; Barcelona; Spain,2016,3
On Reconciling Hardware Atomicity; Memory Models; and tm waiver,Sean White; Michael Spear,A key feature of modern TM language proposals is the __tm_waiver construct [7]; whichprovides a weak form of open nesting where the “waivered” code may not access data that isalso accessed within the calling transaction. The code also cannot use transactions; occursimmediately; and its effects are not rolled back. __tm_waiver can be used to spawn threads;make library and system calls; and communicate with other threads. The programmer isresponsible for preventing races between “waivered” blocks and other code. Unfortunately;__tm_waiver support in hardware TM can break the processor memory consistency model.The problem stems from the fact that the “waivered” code must happen immediately. The twoprominent Best-Effort Hardware Transactional Memory (BEHTM) systems; Sun's Rockprocessor [6] and AMD's Advanced Synchronization Facility (ASF) proposal [1]; illuminate …,2nd Workshop on the Theory of Transactional Memory (WTTM),2010,3
Practical condition synchronization for transactional memory,Chao Wang; Michael Spear,Abstract Few transactional memory implementations allow for condition synchronizationamong transactions. The problems are many; most notably the lack of consensus about asingle appropriate linguistic construct; and the lack of mechanisms that are compatible withhardware transactional memory. In this paper; we introduce a broadly useful mechanism forsupporting condition synchronization among transactions. Our mechanism supports anumber of linguistic constructs for coordinating transactions; and does so without introducingoverhead on in-flight hardware transactions. Experiments show that our mechanisms workwell; and that the diversity of linguistic constructs allows programmers to chose thetechnique that is best suited to a particular application.,Proceedings of the Eleventh European Conference on Computer Systems,2016,2
A new api for transactional condition synchronization,Chao Wang; Yujie Liu; Michael Spear,Abstract In this paper; we introduce a new condition synchronization mechanism based onthe idea of predicates and states. Our algorithm is compatible with hardware; software; andhybrid transactional memories; is simpler to implement than the current state of the art; anddoes not rely on extensive support from run-time libraries.,Proceedings of the 6th Workshop on the Theory of Transactional Memory; Paris; France,2014,2
Brief announcement: Between all and nothing-versatile aborts in hardware transactional memory,Stephan Diestelhorst; Martin Nowack; Michael Spear; Christof Fetzer,Abstract Hardware Transactional Memory (HTM) implementations are becoming available incommercial; off-the-shelf components. While generally comparable; some implementationsdeviate from the strict all-or-nothing property of pure Transactional Memory. We analysethese deviations and find that with small modifications; they can be used to accelerate andsimplify both transactional and non-transactional programming constructs. At the heart of ourextensions we enable access to the transaction's full register state in the abort handler in anexisting HTM without extending the architectural register state. Access to the full registerstate enables applications in both transactional and non-transactional parallel programming:hybrid transactional memory; transactional escape actions; transactional suspend/resume;and alert-on-update.,Proceedings of the twenty-fifth annual ACM symposium on Parallelism in algorithms and architectures,2013,2
Transactions as the foundation of a memory consistency model,Luke Dalessandro; Michael L Scott; Michael F Spear,Abstract We argue that traditional synchronization objects; such as locks; conditions; andatomic/volatile variables; should be defined in terms of transactions; rather than the otherway around. A traditional critical section; in particular; is a region of code; bracketed bytransactions; in which certain data have been privatized. We base our memory model on thenotion of strict serializability (SS); and show that selective relaxation of the relationshipbetween program order and transaction order can allow the implementation of transaction-based locks to be as efficient as conventional locks. We also show that conditionsynchronization can be accommodated without explicit mention of speculation; opacity; oraborted transactions. Finally; we compare SS to the notion of strong isolation (SI); arguingthat SI is neither sufficient for transactional sequential consistency (TSC) nor necessary in …,International Symposium on Distributed Computing,2010,2
Transaction safe nonblocking data structures,Virendra J Marathe; Michael F Spear; Michael L Scott,Abstract This brief announcement focuses on interoperability of software transactions withad hoc nonblocking algorithms. Specifically; we modify arbitrary nonblocking operations sothat (1) they can be used both inside and outside transactions;(2) external uses serializewith transactions; and (3) internal uses succeed if and only if the surrounding transactioncommits. Interoperability enables seemless integration with legacy code; atomic compositionof nonblocking operations; and the equivalent of hand-optimized; closed nestedtransactions.,International Symposium on Distributed Computing,2007,2
Transactions and privatization in Delaunay triangulation,Michael L Scott; Michael F Spear; Luke Dalessandro; Virendra J Marathe,With the rise of multicore processors; much recent attention has focused on transactionalmemory (TM). Unfortunately; the field has yet to develop standard benchmarks to captureapplication characteristics or to facilitate system comparisons. This note describes onecandidate benchmark: an implementation of Delaunay triangulation [4]. Source for thisbenchmark is packaged with Version 3 of the Rochester Software Transactional Memory(RSTM) open-source C++ library [1; 9]. It employs one of the fastest known sequentialalgorithms to triangulate geometrically partitioned regions in parallel; it then employsalternating; barrier-separated phases of transactional and partitioned (“privatized”) work tostitch those regions together. Experiments on multiprocessor and multicore machinesconfirm good speedup and excellent single-thread performance. They also highlight the …,Proceedings of the twenty-sixth annual ACM symposium on Principles of distributed computing,2007,2
Practical experience with transactional lock elision,Tingzhe Zhou; Pante A Zardoshti; Michael Spear,Transactional Memory (TM) promises both to provide a scalable mechanism forsynchronization in concurrent programs; and to offer ease-of-use benefits to programmers.The most straightforward use of TM in real-world programs is in the form of TransactionalLock Elision (TLE). In TLE; critical sections are attempted as transactions; with a fall-back toa lock if conflicts manifest. Thus TLE expects to improve scalability; but not ease ofprogramming. Still; until TLE can deliver performance improvements; transactional styles ofprogramming are unlikely to gain popularity. In this paper; we describe our experiencesemploying TLE in two real-world programs: the PBZip2 file compression tool; and the x265video encoder/decoder. We discuss the obstacles we encountered; propose solutions tothose obstacles; and introduce open challenges. In experiments using the GCC …,Parallel Processing (ICPP); 2017 46th International Conference on,2017,1
Languages Must Expose Memory Heterogeneity,Xiaochen Guo; Aviral Shrivastava; Michael Spear; Gang Tan,Abstract The last decade has seen an explosion in new and innovative memorytechnologies. While certain technologies; like transactional memory; have seen adoption atthe language level; others; such as sandboxed memory; scratchpad memory; and persistentmemory; have not received any systematic programming language support. This is true eventhough the underlying compiler-level mechanisms for these mechanisms are similar. In thispaper; we argue that programming languages must be enhanced to expose heterogeneousmemory technologies to programmers; so that they can enjoy the benefits of thosetechnologies and be able to reason about programs that use the advanced features of novelmemory technologies. We sketch a language design that allows programmers to specifymemory requirements and behaviors; for both data and code. We further describe how a …,Proceedings of the Second International Symposium on Memory Systems,2016,1
Between All and Nothing–Versatile Aborts in Hardware Transactional Memory,Stephan Diestelhorst; Martin Nowack; M Spear; C Fetzer,Abstract Hardware Transactional Memory (HTM) implementations are becoming available incommercial; off-the-shelf components. While generally comparable; some implementationsdeviate from the strict all-or-nothing property of pure Transactional Memory. Instead of tryingto hide them; we lift these deviations to a simple transactional resurrection mechanism thatcan be used to accelerate and simplify both transactional and non-transactionalprogramming constructs. We implement our modifications both architecturally and micro-architecturally in a detailed HTM proposal; without changes to system software and only lightmodifications to the existing HTM microarchitecture. We then show application oftransactional resurrection in both transactional and nontransactional parallel programming:hybrid transactional memory; transactional escape actions; alert-on-update; and …,10th Workshop on Transactional Computing (TRANSACT15),2015,1
Case study: Using transactions in memcached,Michael Spear; Wenjia Ruan; Yujie Liu; Trilok Vyas,Abstract To synthesize the topics in previous chapters of this book; we now turn to thequestion of how to use transactions in real-world code. We use a concrete example;transactionalization of the memcached application; as a vehicle for exploring the challengesand benefits that arise from using transactions instead of locks. Specific topics that receiveattention in this chapter include irrevocability; contention management; language-levelsemantics and privatization; write-through and write-back algorithms; and conditionsynchronization.,*,2015,1
Read; write; play: An educational mobile gaming platform,Jennifer Bayzick; Bradley Askins; Sharon Kalafut; Michael Spear,ABSTRACT We introduce ALE; a new framework for writing games for the Android platform.The primary motivation behind ALE is to emphasize reading code before writing it.Beginners read game code to learn how levels can be made; and advanced users read thecode of ALE itself to learn how to create useful and extensible libraries. To date; roughly 200students at our university have used ALE; ranging from first-semester engineeringundergraduates through Masters students. ALE has proven useful in teaching non-majorsabout CS; in making introductory CS programming courses more exciting; and inencouraging creativity; entrepreneurship; and good program design in upper-level electives.Based on these experiences; we encourage educators at all levels to consider using ALE toimprove students' ability to learn by reading code.,*,2013,1
Hybrid TM Using NOrec STM,Luke Dalessandro; Michael F Spear; Michael L Scott,Transactional memory (TM) aims to simplify parallel programming by providing serializablememory transactions as an extension to the system's memory model. In the context ofincreasing numbers of on-chip processor cores; Sun's Rock processor [3] and AMD'sproposed Advanced Synchronization Facility (ASF)[1] suggest that commercial support forbest-effort hardware TM (HTM) may finally be forthcoming. Best-effort HTMs imposeimplementation-defined limits on the length; size; or behavior of transactions. Rocktransactions; for example; must not make function calls; overflow the write buffer; or sufferevictions of speculatively read cache lines. ASF transactions are guaranteed only four linesof speculatively written state; though more are likely in practice. Neither system supportstransactions that span exceptions or interrupts. Best-effort HTMs suffice for most …,University of Rochester and Lehigh University,2010,1
Fast software transactions,Michael F Spear,Abstract In the past; only a small group of highly-skilled programmers were expected to writeprograms that used multiple processors simultaneously. However; microprocessor vendorshave recently turned to multi-core chip designs as the most profitable way to increaseperformance. We are now seeing multi-core processors in desktops; laptops; handheldcomputers; and even embedded devices. As a result; parallel programming is becoming acore competency for all programmers.,*,2009,1
Hardware acceleration of software transactional memory,Michael Spear; Arrvindh Shriraman; Virendra Marathe; Sandhya Dwarkadas; Michael Scott; David Eisenstat; Christopher Heriot; William Scherer,Abstract Transactional memory (TM) systems seek to increase scalability; reduceprogramming complexity; and overcome the various semantic problems associated withlocks. Software TM proposals run on stock processors and provide substantial flexibility inpolicy; but incur significant overhead for data versioning and validation in the face ofconflicting transactions. Hardware TM proposals have the advantage of speed; but aretypically highly ambitious; embed significant amounts of policy in silicon; and provide noclear migration path for software that must also run on legacy machines. We advocate anintermediate approach; in which hardware is used to accelerate a TM implementationcontrolled fundamentally by software. We present a system; RTM; that embodies thisapproach. It consists of a novel transactional MESI (TMESI) protocol and accompanying …,*,2005,1
A study of unnecessary write backs,Christopher Garman; Xiaochen Guo; Michael Spear,Abstract Emerging non-volatile memory (NVM) technologies are expected to become moreprevalent in caches and main memory due to better scalability into smaller dimensions.Unfortunately; they come with the price of long write latency and high write energy. Wepropose to provide language supports to exploit the programmer's knowledge of theapplications to reduce unnecessary writes to NVM-based caches and main memory. Thiswill allow programmers to write code that will reduce the number of cache write backs thatwill not be needed in the future program execution. This can be done with" hints" that aprogrammer can add to their code to help the system software and hardware to identifyregions of code that can be optimized. A study of the potential benefits of this proposedmechanism is performed on a sequence alignment tool used for bioinformatics. We found …,Proceedings of the International Symposium on Memory Systems,2017,*
Redesigning Go’s Built-In Map to Support Concurrent Operations,Louis Jenkins; Tingzhe Zhou; Michael Spear,The Go language lacks built-in data structures that allow fine-grained concurrent access. Inparticular; its map data type; one of only two generic collections in Go; limits concurrency tothe case where all operations are read-only; any mutation (insert; update; or remove)requires exclusive access to the entire map. The tight integration of this map into the Golanguage and runtime precludes its replacement with known scalable map implementations.This paper introduces the Interlocked Hash Table (IHT). The IHT is the result of language-driven data structure design: it requires minimal changes to the Go map API; supports the fullrange of operations available on the sequential Go map; and provides a path for thelanguage to evolve to become more amenable to scalable computation over shared datastructures. The IHT employs a novel optimistic locking protocol to avoid the risk of …,Parallel Architectures and Compilation Techniques (PACT); 2017 26th International Conference on,2017,*
Brief Announcement: Extending Transactional Memory with Atomic Deferral,Tingzhe Zhou; Victor Luchangco; Michael Spear,Abstract Atomic deferral is a language-level mechanism for transactional memory (TM) thatenables programmers to move output and long-running operations out of a transaction'sbody without sacrificing serializability: the deferred operation appears to execute as part ofits parent transaction; even though it does not make use of TM. We introduce the firstimplementation of atomic deferral; based on transaction-friendly locks; describeenhancements to its API; and demonstrate its effectiveness. Our experiments show thatatomic deferral is useful for its original purpose of moving output operations out oftransactions; and also for moving expensive library calls out of transactions. The result is asignificant improvement in performance for the PARSEC dedup kernel; for both software andhardware TM systems.,Proceedings of the 29th ACM Symposium on Parallelism in Algorithms and Architectures,2017,*
Hand-Over-Hand Transactions with Precise Memory Reclamation,Tingzhe Zhou; Victor Luchangco; Michael Spear,Abstract In this paper; we introduce revocable reservations; a transactional memorymechanism to reserve locations in one transaction and check whether they are unchangedin a subsequent transaction without preventing reserved locations from being reclaimed inthe interim. We describe several implementations of revocable reservations; and show howto use revocable reservations to implement lists and trees with a transactional analog tohand-over-hand locking. Our evaluation of these data structures shows that revocablereservations allow precise and immediate reclamation within transactional data structures;without sacrificing scalability or introducing excessive latency.,Proceedings of the 29th ACM Symposium on Parallelism in Algorithms and Architectures,2017,*
Towards migrating computation to distributed memory caches,Adam Schaub; Michael Spear,Abstract Memcached and other in-memory distributed key-value stores play a critical role inlarge-scale web applications; by reducing traffic to persistent storage and providing an easy-to-access look-aside cache in which programmers can store arbitrary data. These cachestypically have a narrow interface; consisting only of gets; sets; and compare-and-set. In theworst case; this interface can cause significant inefficiencies as clients get large data items;perform small changes; and then set the updated items back into the cache. We extendmemcached to allow clients to execute code directly in the cache. An idealized evaluationon micro-benchmarks based on workload traces from a Cable/Internet service providershows compelling performance; leading to a recommendation that further research beconducted to make in-cache fetch-and-phi safe and programmer-friendly; and that …,Proceedings of the 4th Workshop on Distributed Cloud Computing,2016,*
Transactional Memory Support for C,Michael Wong; Hans Boehm; Justin Gottschlich; Victor Luchangco; Paul McKenney; Maged Michael; Mark Moir; Torvald Riegel; Michael Scott; Tatiana Shpeisman; Michael Spear,Transactional memory supports a programming style that is intended to facilitate parallelexecution with a comparatively gentle learning curve. This document describes a proposaldeveloped by WG21 SG5 to introduce transactional constructs into C++ as a TechnicalSpecification. This document is based on N4514 (http://www. open-std. org/jtc1/sc22/wg21/docs/papers/2015/n4514. pdf) which has been approved to be published as a TechnicalSpecification for C++. This proposal mirrors that approved draft in semantics and syntaxsuitably updated for C based on our design choices as outlined in Section 8. That proposal(N4514) is based in part on the Draft Specification for Transactional Constructs inC++(Version 1.1) published by the Transactional Memory Specification Drafting Group inFebruary 2012. It represents a pragmatic basic set of features; and omits or simplifies a …,*,2015,*
Standard wording for a Transaction-safe C++ Standard Library std:: list,Michael Wong; Jens Maurer; Michael Spear; Justin Gottschlich; Torvald Riegel; Hans Boehm; Victor Luchangco; Maged Michael; Mark Moir; Michael Scott; Tatiana Shpeisman,Abstract This paper documents our effort to transactionalize a C++ Standard TemplateLibrary (STL) container to demonstrate the feasibility of the transactional languageconstructs proposed by Study Group 5 (SG5): Transactional Memory. We began this studywith std:: list and made it transaction-safe using the transactional memory support in GCC4.9. The changes were minimal and were generally restricted to the addition oftransaction_safe keyword to a few interfaces such as allocate; deallocate; and swapfunctions. The rest of the changes were added to internal helper functions. Some of theissues that we considered were the constant time complexity of std:: list. size () and friends;and its const noexcept nature. This experience shows that the safety of STL containers mustnot be specified directly; but instead should be inherited from the type with which the …,*,2014,*
Towards a Transaction-safe C++ Standard Library: std:: list,Justin Gottschlich; Michael Spear; Michael Wong; Hans Boehm; Victor Luchangco; Jens Maurer; Maged Michael; Mark Moir; Torvald Riegel; Michael Scott; Tatiana Shpeisman,Abstract This paper documents our effort to transactionalize a C++ Standard TemplateLibrary (STL) container to demonstrate the feasibility of the transactional languageconstructs proposed by Study Group 5 (SG5): Transactional Memory. We began this studywith std:: list and made it transaction-safe using the transactional memory support in GCC4.9. The changes were minimal and were generally restricted to the addition oftransaction_safe keyword to a few interfaces such as allocate; deallocate; and swapfunctions. The rest of the changes were added to internal helper functions. Some of theissues that we considered were the constant time complexity of std:: list. size () and friends;and its const noexcept nature. This experience shows that the safety of STL containers mustnot be specified directly; but instead should be inherited from the type with which the …,*,2014,*
A nonblocking set optimized for querying the minimum value,Yujie Liu; Michael F Spear,Shared memory run-time systems; such as garbage collectors (GC) and transactionalmemory (TM)[2]; often require global coordination. To keep costs low; designers of thesesystems identify a tradeoff that can prevent bottlenecks without affecting the common case;usually by optimizing the run time of one operation at the expense of other operations. Thefollowing variant is particularly interesting:• There exists some set of states S; and a totalorder< t on the elements in S.,Proceedings of the 30th annual ACM SIGACT-SIGOPS symposium on Principles of distributed computing,2011,*
Hybrid NOrec: A Case Study in the Effectiveness of Best Effort Hardware Transactional Memory,Luke Dalessandro; François Carouge; Sean White; Yossi Lev; Mark Moir; Michael L Scott; Michael F Spear,Abstract Transactional memory (TM) is a promising synchronization mechanism for the nextgeneration of multicore processors. Best-effort Hardware Transactional Memory (HTM)designs; such as Sun's prototype Rock processor and AMD's proposed AdvancedSynchronization Facility (ASF); can efficiently execute many transactions; but abort in somecases due to various limitations. Hybrid TM systems can use a compatible software TM(STM) in such cases. We introduce a family of hybrid TMs built using the recent NOrec STMalgorithm that; unlike existing hybrid approaches; provide both low overhead on hardwaretransactions and concurrent execution of hardware and software transactions. We evaluateimplementations for Rock and ASF; exploring how the differing HTM designs affectoptimization choices. Our investigation yields valuable input for designers of future best …,*,2011,*
Article 54 (23 pages)-A Transactional Memory with Automatic Performance Tuning,Q Wang; S Kulkarni; J Cavazos; M Spear,*,ACM Transactions on Architecture and Code Optimization-TACO,2011,*
Transactional Memory Retry Mechanisms,Michael Scott; Andrew Sveikauskas; Michael Spear,Abstract Software Transactional Memory (STM) systems; if they support conditionsynchronization; typically do so through a retry mechanism. Using retry; a transactionexplicitly self aborts and deschedules itself when it discovers that a precondition for itsoperation does not hold. The underlying implementation may then track the set of locationsread by the retrying transaction; and refrain from scheduling the transaction for re-executionuntil at least one location in the set has been modified by another transaction. While retry iselegant and simple; the conventional implementation has several potential drawbacks thatmay limit both its efficiency and its generality. In this note; we present a retry mechanismbased on Bloom filters that is entirely orthogonal to TM implementation. Our retry iscompatible with hardware; software; and hybrid TM implementations; and has no impact …,*,2008,*
Ordering-Based Semantics for Software Transactional Memory,Michael Scott; Luke Dalessandro; Virendra Marathe; Michael Spear,Abstract It has been widely suggested that memory transactions should behave as if theyacquired and released a single global lock. Unfortunately; this behavior can be expensive toachieve; particularly when---as in the natural publication/privatization idiom---the same dataare accessed both transactionally and nontransactionally. To avoid overhead; we proposeselective strict serializability (SSS) semantics; in which transactions have a global totalorder; but nontransactional accesses are globally ordered only with respect to explicitlymarked transactions. Our definition of SSS formally characterizes the permissible behaviorsof an STM system without recourse to locks. If all transactions are marked; then SSS; single-lock semantics; and database-style strict serializability are equivalent. We evaluate severalSSS implementations in the context of a TL2-like STM system. We also evaluate a weaker …,*,2008,*
Privatization Techniques for Software Transactional Memory,Michael Scott; Virendra Marathe; Luke Dalessandro; Michael Spear,Abstract Early implementations of software transactional memory (STM) assumed thatsharable data would be accessed only within transactions. Memory may appear inconsistentin programs that violate this assumption; even when program logic would seem to makeextra-transactional accesses safe. Designing STM systems that avoid such inconsistencyhas been dubbed the privatization problem. We argue that privatization comprises a pair ofsymmetric subproblems: private operations may fail to see updates made by transactionsthat have committed but not yet completed; conversely; transactions that are doomed buthave not yet aborted may see updates made by private code; causing them to performerroneous; externally visible operations. We explain how these problems arise in differentstyles of STM; present strategies to address them; and discuss their implementation …,*,2007,*
Lowering the Overhead of Nonblocking Software Transactional Memory,Michael Scott; Virendra Marathe; Michael Spear; Christopher Heriot; Athul Acharya; David Eisenstat; William Scherer,Abstract Recent years have seen the development of several different systems for softwaretransactional memory (STM). Most either employ locks in the underlying implementation ordepend on thread-safe general-purpose garbage collection to collect stale data andmetadata. We consider the design of low-overhead; obstruction-free software transactionalmemory for non-garbage-collected languages. Our design eliminates dynamic allocation oftransactional meta-data and co-locates data that are separate in other systems; therebyreducing the expected number of cache misses on the common-case code path; whilepreserving nonblocking progress and requiring no atomic instructions other than single-word load; store; and compare-and-swap (or load-linked/store-conditional). We also employa simple; epoch-based storage management system and introduce a novel conservative …,*,2006,*
Boosting Timestamp-Based TM by Exploiting HW Cycle Counters,Wenjia Ruan; Yujie Liu; Michael Spear,Page 1. Boosting STM with HW Cycle Counters 3/19/2013 1 Boosting Timestamp-Based TMby Exploiting HW Cycle Counters Wenjia Ruan; Yujie Liu; and Michael Spear Lehigh UniversityPage 2. Global Counters… A Blessing and Curse • Starting with TL2 in 2006; virtually everySTM algorithm has accepted a global bottleneck – Exception: visible readers (eg; TLRW) • Somebottlenecks worse than others – Privatization-safe STM → serialized commit – Non-Privatization-safe STM → usually just incrementing a counter • These bottlenecks play a vital role in loweringthe cost of consistency checks – Every writer commits at a unique time – Transactions startrelative to a writer commit time – Easy to determine if a location changed after a transactionstarted – Typically avoids quadratic validation Boosting STM with HW Cycle Counters3/19/2013 2 Page 3. Problems with Global Counters …,*,*,*
Transactional Tools for the Third Decade,Matthew Kilgore; Stephen Louie; Chao Wang; Tingzhe Zhou; Wenjia Ruan; Yujie Liu; Michael Spear,Abstract In this paper; we present the current state of a variety of software tools that we aremaking available to the broad research community. Our intent is to ensure that researchersin Transactional Memory (TM) and related fields have a common baseline that is both easyto use and appropriate for implementing new algorithms and testing hypotheses. The mostsignificant contribution is a transactionalized C++ Standard Template Library. We alsoprovide a proper and extensible lazy software TM implementation; a common buildenvironment; a repackaging of several benchmarks; and a transactional thread-levelspeculation infrastructure. In total; we believe this creates a suitable baseline for researchersin this “third decade” of Transactional Memory.,*,*,*
An Opaque Hybrid Transactional Memory,Wenjia Ruan; Michael Spear,Abstract The arrival of best-effort hardware transactional memory (TM) creates a challengefor designers of transactional memory runtime libraries. On the one hand; using hardwareTM can dramatically reduce the latency of transactions. On the other; it is critical to create afall-back path to handle the cases where hardware TM cannot complete a transaction; andthis path ought to be scalable and reasonably fair to all transactions. Additionally; while thehardwareaccelerated system is likely to have weaker safety guarantees than a purehardware TM; it ought not to be weaker than what software TM guarantees. We propose anew hybrid TM algorithm based on the “Cohorts” software TM algorithm. Our algorithmguarantees opacity by preventing any transaction from observing the un-committed state ofany other transaction. It does so via a novel state machine that maximizes the use of …,*,*,*
On the Relationship Between Delaying Operators and Language-Level Semantics,Wenjia Ruan; Yujie Liu; Michael Spear,Abstract The notion of “atomicity” implies that it is safe to rearrange memory accesses withina transaction. In this paper; we sketch a mechanism for postponing contentious transactionaloperations until commit time; where they become impervious to aborts. We then contemplatethe interplay between such a mechanism and languagelevel semantics. Though preliminary;our algorithms and recommendations should prove useful to designers of transactionalcompilers and languages.,*,*,*
Contributions summary; TRAMP Workshop; February 2007,Michael L Scott; Sandhya Dwarkadas; William N Scherer III; Virendra J Marathe; Michael F Spear; Arrvindh Shriraman; Vinod Sivasankaran; Hemayet Hossain; Luke Dalessandro; Athul Acharya; Chris Heriot; David Eisenstat; Aaron Rolett,Bill Scherer; now a Faculty Fellow at Rice University but then a graduate student intern; waspart of the original team that developed the Dynamic STM (DSTM) system at Sun Labs [4].As part of his thesis work; he developed and evaluated a large suite of pluggable contentionmanagers for obstruction-free STM [14; 17; 18]. Virendra Marathe began his graduate careerwith an early analysis of design tradeoffs for practical STM [6; 7]. This work led to the Java-based ASTM system; which adapts its degree of eagerness and level of indirection based oncharacteristics of the offered workload [8]. Virendra also showed how to use load-linked/store-conditional to simplify and optimize Harris and Fraser's word-based STM(WSTM)[9]. More recently; together with Mark Moir of Sun Labs; he has developed a generalapproach to nonblocking copyback in word-based STM [12]. In 2005 we began to shift our …,*,*,*
Mindicator: A Nonblocking Set Optimized for Querying the Minimum Value,Yujie Liu; Michael Spear,Abstract We present the Mindicator; a set implementation customized for shared memoryruntime systems. The Mindicator is optimized for constant-time querying of its minimumelement; while ensuring scalability as the number of threads adding and removing elementsfrom the set grows. We introduce a lock-free Mindicator and prove its correctness. We alsointroduce lock-based and quiescently consistent Mindicators; and show that all provide goodscalability on both the Intel x86 and Sun SPARC platforms. The strong performance ofMindicators make them suitable for use in high-performance run-time systems; such asgarbage collectors; transactional memory; and operating system kernels.,*,*,*
Brief Announcement: A Nonblocking Set Optimized for Querying the Minimum Value,Yujie Liu; Michael Spear,Shared memory run-time systems; such as garbage collectors (GC) and transactionalmemory (TM)[2]; often require global coordination. To keep costs low; designers of thesesystems identify a tradeoff that can prevent bottlenecks without affecting the common case;usually by optimizing the run time of one operation at the expense of other operations. Thefollowing variant is particularly interesting:• There exists some set of states S; and a totalorder< t on the elements in S.,*,*,*
