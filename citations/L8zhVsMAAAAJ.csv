Lightweight modular staging: a pragmatic approach to runtime code generation and compiled DSLs,Tiark Rompf; Martin Odersky,Abstract Software engineering demands generality and abstraction; performance demandsspecialization and concretization. Generative programming can provide both; but the effortrequired to develop high-quality program generators likely offsets their benefits; even if amulti-stage programming language is used. We present lightweight modular staging; alibrary-based multi-stage programming approach that breaks with the tradition of syntacticquasi-quotation and instead uses only types to distinguish between binding times. Throughextensive use of component technology; lightweight modular staging makes an optimizingcompiler framework available at the library level; allowing programmers to tightly integratedomain-specific abstractions and optimizations into the generation process.,Acm Sigplan Notices,2010,219
A heterogeneous parallel framework for domain-specific languages,Kevin J Brown; Arvind K Sujeeth; Hyouk Joong Lee; Tiark Rompf; Hassan Chafi; Martin Odersky; Kunle Olukotun,Computing systems are becoming increasingly parallel and heterogeneous; and thereforenew applications must be capable of exploiting parallelism in order to continue achievinghigh performance. However; targeting these emerging devices often requires using multipledisparate programming models and making decisions that can limit forward scalability. Inprevious work we proposed the use of domain-specific languages (DSLs) to provide high-level abstractions that enable transformations to high performance parallel code withoutdegrading programmer productivity. In this paper we present a new end-to-end system forbuilding; compiling; and executing DSL applications on parallel heterogeneous hardware;the Delite Compiler Framework and Runtime. The framework lifts embedded DSLapplications to an intermediate representation (IR); performs generic; parallel; and …,Parallel Architectures and Compilation Techniques (PACT); 2011 International Conference on,2011,172
OptiML: an implicitly parallel domain-specific language for machine learning,Arvind Sujeeth; HyoukJoong Lee; Kevin Brown; Tiark Rompf; Hassan Chafi; Michael Wu; Anand Atreya; Martin Odersky; Kunle Olukotun,Abstract As the size of datasets continues to grow; machine learning applications arebecoming increasingly limited by the amount of available computational power. Takingadvantage of modern hardware requires using multiple parallel programming modelstargeted at different devices (eg CPUs and GPUs). However; programming these devices torun efficiently and correctly is difficult; error-prone; and results in software that is harder toread and maintain. We present OptiML; a domain-specific language (DSL) for machinelearning. OptiML is an implicitly parallel; expressive and high performance alternative toMATLAB and C++. OptiML performs domain-specific analyses and optimizations andautomatically generates CUDA code for GPUs. We show that OptiML outperforms explicitlyparallelized MATLAB code in nearly all cases.,Proceedings of the 28th International Conference on Machine Learning (ICML-11),2011,148
Language virtualization for heterogeneous parallel computing,Hassan Chafi; Zach DeVito; Adriaan Moors; Tiark Rompf; Arvind K Sujeeth; Pat Hanrahan; Martin Odersky; Kunle Olukotun,Abstract As heterogeneous parallel systems become dominant; application developers arebeing forced to turn to an incompatiblemix of low level programming models (eg OpenMP;MPI; CUDA; OpenCL). However; these models do little to shield developers from the difficultproblems of parallelization; data decomposition and machine-specific details. Mostprogrammersare having a difficult time using these programming models effectively. Toprovide a programming modelthat addresses the productivity and performance requirementsfor the average programmer; we explore a domainspecificapproach to heterogeneousparallel programming. We propose language virtualization as a new principle that enablesthe construction of highly efficient parallel domain specific languages that are embedded ina common host language. We define criteria for language virtualization and present …,ACM Sigplan Notices,2010,117
Lightweight modular staging: a pragmatic approach to runtime code generation and compiled DSLs,Tiark Rompf; Martin Odersky,Abstract Good software engineering practice demands generalization and abstraction;whereas high performance demands specialization and concretization. These goals are atodds; and compilers can only rarely translate expressive high-level programs to modernhardware platforms in a way that makes best use of the available resources. Generativeprogramming is a promising alternative to fully automatic translation. Instead of writing downthe target program directly; developers write a program generator; which produces the targetprogram as its output. The generator can be written in a high-level; generic style and can stillproduce efficient; specialized target programs. In practice; however; developing high-qualityprogram generators requires a very large effort that is often hard to amortize.,Communications of the ACM,2012,92
Delite: A compiler architecture for performance-oriented embedded domain-specific languages,Arvind K Sujeeth; Kevin J Brown; Hyoukjoong Lee; Tiark Rompf; Hassan Chafi; Martin Odersky; Kunle Olukotun,Abstract Developing high-performance software is a difficult task that requires the use of low-level; architecture-specific programming models (eg; OpenMP for CMPs; CUDA for GPUs;MPI for clusters). It is typically not possible to write a single application that can run efficientlyin different environments; leading to multiple versions and increased complexity. Domain-Specific Languages (DSLs) are a promising avenue to enable programmers to use high-level abstractions and still achieve good performance on a variety of hardware. This ispossible because DSLs have higher-level semantics and restrictions than general-purposelanguages; so DSL compilers can perform higher-level optimization and translation.However; the cost of developing performance-oriented DSLs is a substantial roadblock totheir development and adoption. In this article; we present an overview of the Delite …,ACM Transactions on Embedded Computing Systems (TECS),2014,88
Optimizing data structures in high-level programs: New directions for extensible compilers based on staging,Tiark Rompf; Arvind K Sujeeth; Nada Amin; Kevin J Brown; Vojin Jovanovic; HyoukJoong Lee; Manohar Jonnalagedda; Kunle Olukotun; Martin Odersky,Abstract High level data structures are a cornerstone of modern programming and at thesame time stand in the way of compiler optimizations. In order to reason about user-or library-defined data structures compilers need to be extensible. Common mechanisms to extendcompilers fall into two categories. Frontend macros; staging or partial evaluation systemscan be used to programmatically remove abstraction and specialize programs before theyenter the compiler. Alternatively; some compilers allow extending the internal workings byadding new transformation passes at different points in the compile chain or adding newintermediate representation (IR) types. None of these mechanisms alone is sufficient tohandle the challenges posed by high level data structures. This paper shows a novel way tocombine them to yield benefits that are greater than the sum of the parts. Instead of using …,POPL,2013,88
Implementing first-class polymorphic delimited continuations by a type-directed selective CPS-transform,Tiark Rompf; Ingo Maier; Martin Odersky,Abstract We describe the implementation of first-class polymorphic delimited continuationsin the programming language Scala. We use Scala's pluggable typing architecture toimplement a simple type and effect system; which discriminates expressions with controleffects from those without and accurately tracks answer type modification incurred by controleffects. To tackle the problem of implementing first-class continuations under the adverseconditions brought upon by the Java VM; we employ a selective CPS transform; which isdriven entirely by effect-annotated types and leaves pure code in direct style. Benchmarksindicate that this high-level approach performs competitively.,ACM Sigplan Notices,2009,88
A generic parallel collection framework,Aleksandar Prokopec; Phil Bagwell; Tiark Rompf; Martin Odersky,Abstract Most applications manipulate structured data. Modern languages and platformsprovide collection frameworks with basic data structures like lists; hashtables and trees.These data structures have a range of predefined operations which include mapping;filtering or finding elements. Such bulk operations traverse the collection and process theelements sequentially. Their implementation relies on iterators; which are not applicable toparallel operations due to their sequential nature. We present an approach to parallelizingcollection operations in a generic way; used to factor out common parallel operations incollection libraries. Our framework is easy to use and straightforward to extend to newcollections. We show how to implement concrete parallel collections such as parallel arraysand parallel hash maps; proposing an efficient solution to parallel hash map construction …,European Conference on Parallel Processing,2011,80
Building efficient query engines in a high-level language,Yannis Klonatos; Christoph Koch; Tiark Rompf; Hassan Chafi,Abstract In this paper we advocate that it is time for a radical rethinking of database systemsdesign. Developers should be able to leverage high-level programming languages withouthaving to pay a price in efficiency. To realize our vision of abstraction without regret; wepresent LegoBase; a query engine written in the high-level programming language Scala.The key technique to regain efficiency is to apply generative programming: the Scala codethat constitutes the query engine; despite its high-level appearance; is actually a programgenerator that emits specialized; low-level C code. We show how the combination of high-level and generative programming allows to easily implement a wide spectrum ofoptimizations that are difficult to achieve with existing low-level query compilers; and how itcan continuously optimize the query engine. We evaluate our approach with the TPC-H …,Proceedings of the VLDB Endowment,2014,73
Building-blocks for performance oriented DSLs,Tiark Rompf; Arvind K Sujeeth; HyoukJoong Lee; Kevin J Brown; Hassan Chafi; Martin Odersky; Kunle Olukotun,Abstract: Domain-specific languages raise the level of abstraction in software development.While it is evident that programmers can more easily reason about very high-level programs;the same holds for compilers only if the compiler has an accurate model of the applicationdomain and the underlying target platform. Since mapping high-level; general-purposelanguages to modern; heterogeneous hardware is becoming increasingly difficult; DSLs arean attractive way to capitalize on improved hardware performance; precisely by making thecompiler reason on a higher level. Implementing efficient DSL compilers is a daunting taskhowever; and support for building performance-oriented DSLs is urgently needed. To thisend; we present the Delite Framework; an extensible toolkit that drastically simplifiesbuilding embedded DSLs and compiling DSL programs for execution on heterogeneous …,arXiv preprint arXiv:1109.0778,2011,62
Implementing domain-specific languages for heterogeneous parallel computing,HyoukJoong Lee; Kevin Brown; Arvind Sujeeth; Hassan Chafi; Tiark Rompf; Martin Odersky; Kunle Olukotun,Domain-specific languages offer a solution to the performance and the productivity issues inheterogeneous computing systems. The Delite compiler framework simplifies the process ofbuilding embedded parallel DSLs. DSL developers can implement domain-specificoperations by extending the DSL framework; which provides static optimizations and codegeneration for heterogeneous hardware. The Delite runtime automatically schedules andexecutes DSL operations on heterogeneous hardware.,Ieee Micro,2011,61
Composition and reuse with compiled domain-specific languages,Arvind K Sujeeth; Tiark Rompf; Kevin J Brown; H Lee; Hassan Chafi; Victoria Popic; Michael Wu; Aleksander Prokopec; Vojin Jovanovic; Martin Odersky; Kunle Olukotun,Abstract Programmers who need high performance currently rely on low-level; architecture-specific programming models (eg OpenMP for CMPs; CUDA for GPUs; MPI for clusters).Performance optimization with these frameworks usually requires expertise in the specificprogramming model and a deep understanding of the target architecture. Domain-specificlanguages (DSLs) are a promising alternative; allowing compilers to map problem-specificabstractions directly to low-level architecture-specific programming models. However;developing DSLs is difficult; and using multiple DSLs together in a single application is evenharder because existing compiled solutions do not compose together. In this paper; wepresent four new performance-oriented DSLs developed with Delite; an extensible DSLcompilation framework. We demonstrate new techniques to compose compiled DSLs …,Proceedings of ECOOP,2013,55
Scala-virtualized,Adriaan Moors; Tiark Rompf; Philipp Haller; Martin Odersky,Abstract Scala-Virtualized extends the Scala language to better support hosting embeddedDSLs. Embedding a DSL in Scala-Virtualized comes with all the benefits of a shallowembedding thanks to Scala's flexible syntax; without giving up analyzing and manipulatingthe domain program--typically exclusive to deep embeddings. Through lightweight modularstaging; implemented in standard Scala; the benefits of a deep embedding are recoveredwith little overhead. Scala-Virtualized lifts more of the language's built-in constructs andstatic information to complete this support and make it more convenient. We illustrate howScala-Virtualized makes Scala an even better host for embedded DSLs along three axes ofcustomizing the language: syntax; run-time behavior and static semantics.,Proceedings of the ACM SIGPLAN 2012 workshop on Partial evaluation and program manipulation,2012,51
Deprecating the Observer Pattern with Scala. React,Ingo Maier; Martin Odersky,Abstract Programming interactive systems by means of the observer pattern is hard anderror-prone yet is still the implementation standard in many production environments. Weshow how to integrate different reactive programming abstractions into a single frameworkthat help migrate from observer-based event handling logic to more declarativeimplementations. Our central API layer embeds an extensible higher-order data-flow DSLinto our host language. This embedding is enabled by a continuation passing styletransformation.,*,2012,47
Spiral in scala: towards the systematic construction of generators for performance libraries,Georg Ofenbeck; Tiark Rompf; Alen Stojanov; Martin Odersky; Markus Püschel,Abstract Program generators for high performance libraries are an appealing solution to therecurring problem of porting and optimizing code with every new processor generation; butonly few such generators exist to date. This is due to not only the difficulty of the design; butalso of the actual implementation; which often results in an ad-hoc collection of standaloneprograms and scripts that are hard to extend; maintain; or reuse. In this paper we askwhether and which programming language concepts and features are needed to enable amore systematic construction of such generators. The systematic approach we advocateextrapolates from existing generators: a) describing the problem and algorithmic knowledgeusing one; or several; domain-specific languages (DSLs); b) expressing optimizations andchoices as rewrite rules on DSL programs; c) designing data structures that can be …,Acm Sigplan Notices,2013,41
Locality-aware mapping of nested parallel patterns on gpus,HyoukJoong Lee; Kevin J Brown; Arvind K Sujeeth; Tiark Rompf; Kunle Olukotun,Recent work has explored using higher level languages to improve programmer productivityon GPUs. These languages often utilize high level computation patterns (eg; Map andReduce) that encode parallel semantics to enable automatic compilation to GPU kernels.However; the problem of efficiently mapping patterns to GPU hardware becomessignificantly more difficult when the patterns are nested; which is common in non-trivialapplications. To address this issue; we present a general analysis framework forautomatically and efficiently mapping nested patterns onto GPUs. The analysis maps nestedpatterns onto a logical multidimensional domain and parameterizes the block size anddegree of parallelism in each dimension. We then add GPU-specific hard and softconstraints to prune the space of possible mappings and select the best mapping. We …,Microarchitecture (MICRO); 2014 47th Annual IEEE/ACM International Symposium on,2014,37
Hardware system synthesis from domain-specific languages,Nithin George; HyoukJoong Lee; David Novo; Tiark Rompf; Kevin J Brown; Arvind K Sujeeth; Martin Odersky; Kunle Olukotun; Paolo Ienne,Field Programmable Gate Arrays (FPGAs) are very versatile devices; but their complicatedprogramming model has stymied their widespread usage. While modern High-LevelSynthesis (HLS) tools provide better programming models; the interface they offer is still toolow-level. In order to produce good quality hardware designs with these tools; the users areforced to manually perform optimizations that demand detailed knowledge of both theapplication and the implementation platform. Additionally; many HLS tools only generateisolated hardware modules that the user still needs to integrate into a system design beforegenerating the FPGA bitstream. These problems make HLS tools difficult to use forapplication developers who have little hardware design knowledge. To address theseproblems; we propose an automated methodology to generate FPGA bitstreams from …,Field Programmable Logic and Applications (FPL); 2014 24th International Conference on,2014,37
Scala-Virtualized: linguistic reuse for deep embeddings,Tiark Rompf; Nada Amin; Adriaan Moors; Philipp Haller; Martin Odersky,Abstract Scala-Virtualized extends the Scala language to better support hosting embeddedDSLs. Scala is an expressive language that provides a flexible syntax; type-levelcomputation using implicits; and other features that facilitate the development of embeddedDSLs. However; many of these features work well only for shallow embeddings; ie DSLswhich are implemented as plain libraries. Shallow embeddings automatically profit fromfeatures of the host language through linguistic reuse: any DSL expression is just as aregular Scala expression. But in many cases; directly executing DSL programs within thehost language is not enough and deep embeddings are needed; which reify DSL programsinto a data structure representation that can be analyzed; optimized; or further translated. Fordeep embeddings; linguistic reuse is no longer automatic. Scala-Virtualized defines many …,Higher-Order and Symbolic Computation,2012,36
Surgical precision JIT compilers,Tiark Rompf; Arvind K Sujeeth; Kevin J Brown; HyoukJoong Lee; Hassan Chafi; Kunle Olukotun,Abstract Just-in-time (JIT) compilation of running programs provides more optimizationopportunities than offline compilation. Modern JIT compilers; such as those in virtualmachines like Oracle's HotSpot for Java or Google's V8 for JavaScript; rely on dynamicprofiling as their key mechanism to guide optimizations. While these JIT compilers offer goodaverage performance; their behavior is a black box and the achieved performance is highlyunpredictable. In this paper; we propose to turn JIT compilation into a precision tool byadding two essential and generic metaprogramming facilities: First; allow programs toinvoke JIT compilation explicitly. This enables controlled specialization of arbitrary code atrun-time; in the style of partial evaluation. It also enables the JIT compiler to report warningsand errors to the program when it is unable to compile a code path in the demanded way …,Acm Sigplan Notices,2014,33
Lightweight modular staging and embedded compilers: Abstraction without regret for high-level high-performance programming,Tiark Rompf,Abstract Programs expressed in a high-level programming language need to be translatedto a low-level machine dialect for execution. This translation is usually accomplished by acompiler; which is able to translate any legal program to equivalent low-level code. But forindividual source programs; automatic translation does not always deliver good results:Software engineering practice demands generalization and abstraction; whereas highperformance demands specialization and concretization. These goals are at odds; andcompilers can only rarely translate expressive high-level programs to modern hardwareplatforms in a way that makes best use of the available resources. Explicit programgeneration is a promising alternative to fully automatic translation. Instead of writing downthe program and relying on a compiler for translation; developers write a program …,ÉCOLE POLYTECHNIQUE FÉDÉRALE DE LAUSANNE,2012,33
JavaScript as an embedded DSL,Grzegorz Kossakowski; Nada Amin; Tiark Rompf; Martin Odersky,Abstract Developing rich web applications requires mastering different environments on theclient and server sides. While there is considerable choice on the server-side; the client-sideis tied to JavaScript; which poses substantial software engineering challenges; such asmoving or sharing pieces of code between the environments. We embed JavaScript as aDSL in Scala; using Lightweight Modular Staging. DSL code can be compiled to JavaScriptor executed as part of the server application. We use features of the host language to makeclient-side programming safer and more convenient. We use gradual typing to interfacetyped DSL programs with existing JavaScript APIs. We exploit a selective CPS transformalready available in the host language to provide a compelling abstraction overasynchronous callback-driven programming in our DSL.,European Conference on Object-Oriented Programming,2012,26
The essence of dependent object types,Nada Amin; Samuel Grütter; Martin Odersky; Tiark Rompf; Sandro Stucki,Abstract Focusing on path-dependent types; the paper develops foundations for Scala fromfirst principles. Starting from a simple calculus D _<:<: of dependent functions; it addsrecords; intersections and recursion to arrive at DOT; a calculus for dependent object types.The paper shows an encoding of System F with subtyping in D _<:<: and demonstrates theexpressiveness of DOT by modeling a range of Scala constructs in it.,*,2016,25
Foundations of path-dependent types,Nada Amin; Tiark Rompf; Martin Odersky,Abstract A scalable programming language is one in which the same concepts can describesmall as well as large parts. Towards this goal; Scala unifies concepts from object andmodule systems. An essential ingredient of this unification is the concept of objects with typemembers; which can be referenced through path-dependent types. Unfortunately; path-dependent types are not well-understood; and have been a roadblock in grounding theScala type system on firm theory. We study several calculi for path-dependent types. Wepresent DOT which captures the essence-DOT stands for Dependent Object Types. Weexplore the design space bottom-up; teasing apart inherent from accidental complexities;while fully mechanizing our models at each step. Even in this simple setting; manyinteresting patterns arise from the interaction of structural and nominal features.,Acm Sigplan Notices,2014,23
Jet: An embedded DSL for high performance big data processing,Stefan Ackermann; Vojin Jovanovic; Tiark Rompf; Martin Odersky,ABSTRACT Cluster computing systems today impose a trade-off between generality;performance and productivity. Hadoop and Dryad force programmers to write low levelprograms that are tedious to compose but easy to optimize. Systems like Dryad/LINQ andSpark allow concise modeling of user programs but do not apply relational optimizations.Pig and Hive restrict the language to achieve relational optimizations; making complexprograms hard to express without user extensions. However; these extensions arecumbersome to write and disallow program optimizations. We present a distributed batchdata processing framework called Jet. Jet uses deep language embedding in Scala; multi-stage programming and explicit side effect tracking to analyze the structure of userprograms. The analysis is used to apply projection insertion; which eliminates unused …,International Workshop on End-to-end Management of Big Data (BigData 2012),2012,23
Unifying functional and object-oriented programming with Scala,Martin Odersky; Tiark Rompf,Java libraries are accessible from Scala without needing wrappers or other glue code.Designing Scala libraries so they can be accessed from Java code is also relativelystraightforward. Moreover; Scala is a statically typed language that compiles to the samebytecodes as Java and runs at comparable speed. 6 Several necessary compromisesfollowed from the interoperability goal; for instance; Scala adopts Java's method overloadingscheme; even though one could say multi-methods in the style of Fortress1 would havebeen cleaner. Another is that Scala allows null pointers; called by their originator; TonyHoare; the “billion-dollar mistake.” This is again important for interoperability with Java.However; in pure Scala code null pointers are usually avoided in favor of the standardOption type. The second ingredient for Scala's impressive adoption history is that it rides …,Communications of the ACM,2014,21
Forge: generating a high performance DSL implementation from a declarative specification,Arvind K Sujeeth; Austin Gibbons; Kevin J Brown; HyoukJoong Lee; Tiark Rompf; Martin Odersky; Kunle Olukotun,Abstract Domain-specific languages provide a promising path to automatically compile high-level code to parallel; heterogeneous; and distributed hardware. However; in practice highperformance DSLs still require considerable software expertise to develop and force usersinto tool-chains that hinder prototyping and debugging. To address these problems; wepresent Forge; a new meta DSL for declaratively specifying high performance embeddedDSLs. Forge provides DSL authors with high-level abstractions (eg; data structures; parallelpatterns; effects) for specifying their DSL in a way that permits high performance. From thishigh-level specification; Forge automatically generates both a naïve Scala libraryimplementation of the DSL and a high performance version using the Delite DSL framework.Users of a Forge-generated DSL can prototype their application using the library version …,Acm Sigplan Notices,2013,21
Have abstraction and eat performance; too: Optimized heterogeneous computing with parallel patterns,Kevin J Brown; HyoukJoong Lee; Tiark Romp; Arvind K Sujeeth; Christopher De Sa; Christopher Aberger; Kunle Olukotun,High performance in modern computing platforms requires programs to be parallel;distributed; and run on heterogeneous hardware. However programming such architecturesis extremely difficult due to the need to implement the application using multipleprogramming models and combine them together in ad-hoc ways. To optimize distributedapplications both for modern hardware and for modern programmers we need aprogramming model that is sufficiently expressive to support a variety of parallelapplications; sufficiently performant to surpass hand-optimized sequential implementations;and sufficiently portable to support a variety of heterogeneous hardware. Unfortunatelyexisting systems tend to fall short of these requirements. In this paper we introduce theDistributed Multiloop Language (DMLL); a new intermediate language based on common …,Code Generation and Optimization (CGO); 2016 IEEE/ACM International Symposium on,2016,19
Type Soundness Proofs with Definitional Interpreters,Nada Amin; Tiark Rompf,Abstract While type soundness proofs are taught in every graduate PL class; the gapbetween realistic languages and what is accessible to formal proofs is large. In the case ofScala; it has been shown that its formal model; the Dependent Object Types (DOT) calculus;cannot simultaneously support key metatheoretic properties such as environment narrowingand subtyping transitivity; which are usually required for a type soundness proof. Moreover;Scala and many other realistic languages lack a general substitution property. The firstcontribution of this paper is to demonstrate how type soundness proofs for advanced;polymorphic; type systems can be carried out with an operational semantics based on high-level; definitional interpreters; implemented in Coq. We present the first mechanizedsoundness proofs in this style for System F and several extensions; including mutable …,*,2016,18
RRB vector: a practical general purpose immutable sequence,Nicolas Stucki; Tiark Rompf; Vlad Ureche; Phil Bagwell,Abstract State-of-the-art immutable collections have wildly differing performancecharacteristics across their operations; often forcing programmers to choose differentcollection implementations for each task. Thus; changes to the program can invalidate thechoice of collections; making code evolution costly. It would be desirable to have a collectionthat performs well for a broad range of operations. To this end; we present the RRB-Vector;an immutable sequence collection that offers good performance across a large number ofsequential and parallel operations. The underlying innovations are:(1) the Relaxed-Radix-Balanced (RRB) tree structure; which allows efficient structural reorganization; and (2) anoptimization that exploits spatio-temporal locality on the RRB data structure in order to offsetthe cost of traversing the tree. In our benchmarks; the RRB-Vector speedup for parallel …,ACM SIGPLAN Notices,2015,16
Type soundness for dependent object types (DOT),Tiark Rompf; Nada Amin,Abstract Scala's type system unifies aspects of ML modules; object-oriented; and functionalprogramming. The Dependent Object Types (DOT) family of calculi has been proposed as anew theoretic foundation for Scala and similar expressive languages. Unfortunately; typesoundness has only been established for restricted subsets of DOT. In fact; it has beenshown that important Scala features such as type refinement or a subtyping relation withlattice structure break at least one key metatheoretic property such as environmentnarrowing or invertible subtyping transitivity; which are usually required for a typesoundness proof. The main contribution of this paper is to demonstrate how; perhapssurprisingly; even though these properties are lost in their full generality; a rich DOT calculusthat includes recursive type refinement and a subtyping lattice with intersection types can …,Acm Sigplan Notices,2016,15
Computing with an SMT Solver.,Nada Amin; K Rustan M Leino; Tiark Rompf,Abstract. Satisfiability modulo theories (SMT) solvers that support quantifier instantiations viamatching triggers can be programmed to give practical support for user-defined theories.Care must be taken to avoid so-called matching loops; which may prevent termination of thesolver. By design; such avoidance limits the extent to which the SMT solver is able to applythe definitions of user-defined functions. For some inputs to these functions; however; it isinstead desireable to allow unadulterated use of the functions; in particular; if it is known thatevaluation will terminate. This paper describes the program verifier Dafny's SMT encoding ofrecursive user-defined functions. It then describes a novel encoding that; drawing on ideasfrom offline partial evaluation systems; lets the SMT solver evaluate “safe” functionapplications while guarding against matching loops for others.,TAP,2014,15
Making domain-specific hardware synthesis tools cost-efficient,Nithin George; David Novo; Tiark Rompf; Martin Odersky; Paolo Ienne,Tools to design hardware at a high level of abstraction promise software-like productivity forhardware designs. Among them; tools like Spiral; HDL Coder; Optimus and MMAlpha targetspecific application domains and produce highly efficient implementations from high-levelinput specifications in a Domain Specific Language (DSL). But; developing similar domain-specific High-Level Synthesis (HLS) tools need enormous effort; which might offset theirmany advantages. In this paper; we propose a novel; cost-effective approach to developdomain-specific HLS tools. We develop the HLS tool by embedding its input DSL in Scalaand using Lightweight Modular Staging (LMS); a compiler framework written in Scala; toperform optimizations at different abstraction levels. For example; to optimize computationon matrices; some optimizations are more effective when the program is represented at …,Field-Programmable Technology (FPT); 2013 International Conference on,2013,15
Staged parser combinators for efficient data processing,Manohar Jonnalagedda; Thierry Coppey; Sandro Stucki; Tiark Rompf; Martin Odersky,Abstract Parsers are ubiquitous in computing; and many applications depend on theirperformance for decoding data efficiently. Parser combinators are an intuitive tool for writingparsers: tight integration with the host language enables grammar specifications to beinterleaved with processing of parse results. Unfortunately; parser combinators are typicallyslow due to the high overhead of the host language abstraction mechanisms that enablecomposition. We present a technique for eliminating such overhead. We use staging; a formof runtime code generation; to dissociate input parsing from parser composition; andeliminate intermediate data structures and computations associated with parser compositionat staging time. A key challenge is to maintain support for input dependent grammars; whichhave no clear stage distinction.,Acm Sigplan Notices,2014,14
Stagedsac: A case study in performance-oriented dsl development,Vlad Ureche; Tiark Rompf; Arvind Sujeeth; Hassan Chafi; Martin Odersky,Abstract Domain-specific languages (DSLs) can bridge the gap between high-levelprogramming and efficient execution. However; implementing compiler tool-chains forperformance oriented DSLs requires significant effort. Recent research has producedmethodologies and frameworks that promise to reduce this development effort by enablingquick transition from library-only; purely embedded DSLs to optimizing compilation. In thiscase study we report on our experience implementing a compiler for StagedSAC.StagedSAC is a DSL for arithmetic processing with multidimensional arrays modeled afterthe stand-alone language SAC (Single Assignment C). The main language feature of bothSAC and StagedSAC is a loop construction that enables high-level and conciseimplementations of array algorithms. At the same time; the functional semantics of the two …,Proceedings of the ACM SIGPLAN 2012 workshop on Partial evaluation and program manipulation,2012,14
RRB-Trees: Efficient Immutable Vectors,Philip Bagwell; Tiark Rompf,Abstract Immutable vectors are a convenient data structure for functional programming andpart of the standard library of modern languages like Clojure and Scala. The commonimplementation is based on wide trees with a fixed number of children per node; whichallows fast indexed lookup and update operations. In this paper we extend the vector datatype with a new underlying data structure; Relaxed Radix Balanced Trees (RRB-Trees); andshow how this structure allows immutable vector concatenation; insert-at and splits in O(logN) time while maintaining the index; update and iteration speeds of the original vectordata structure.,*,2011,12
Functional pearl: a SQL to C compiler in 500 lines of code,Tiark Rompf; Nada Amin,Abstract We present the design and implementation of a SQL query processor thatoutperforms existing database systems and is written in just about 500 lines of Scala code--aconvincing case study that high-level functional programming can handily beat C forsystems-level programming where the last drop of performance matters. The key enabler isa shift in perspective towards generative programming. The core of the query engine is aninterpreter for relational algebra operations; written in Scala. Using the open-source LMSFramework (Lightweight Modular Staging); we turn this interpreter into a query compiler withvery low effort. To do so; we capitalize on an old and widely known result from partialevaluation known as Futamura projections; which state that a program that can specialize aninterpreter to any given input program is equivalent to a compiler. In this pearl; we discuss …,Acm Sigplan Notices,2015,11
Go meta! A case for generative programming and dsls in performance critical systems,Tiark Rompf; Kevin J Brown; HyoukJoong Lee; Arvind K Sujeeth; Manohar Jonnalagedda; Nada Amin; Georg Ofenbeck; Alen Stojanov; Yannis Klonatos; Mohammad Dashti; Christoph Koch; Markus Püschel; Kunle Olukotun,Abstract Most performance critical software is developed using very low-level techniques.We argue that this needs to change; and that generative programming is an effective avenueto enable the use of high-level languages and programming techniques in many suchcircumstances.,LIPIcs-Leibniz International Proceedings in Informatics,2015,10
From F to DOT: Type soundness proofs with definitional interpreters,Tiark Rompf; Nada Amin,Abstract: Scala's type system unifies ML modules; object-oriented; and functionalprogramming. The Dependent Object Types (DOT) family of calculi has been proposed as anew foundation for Scala and similar languages. Unfortunately; it is not clear how DOTrelates to any well-known type systems; and type soundness has only been established forvery restricted subsets. In fact; important Scala features are known to break at least one keymetatheoretic property such as environment narrowing or subtyping transitivity; which areusually required for a type soundness proof. First; and; perhaps surprisingly; we show howrich DOT calculi can still be proved sound. The key insight is that narrowing and subtypingtransitivity only need to hold for runtime objects; but not for code that is never executed. Alas;the dominant method of proving type soundness; Wright and Felleisen's syntactic …,arXiv preprint arXiv:1510.05216,2015,9
Flare: Native compilation for heterogeneous workloads in Apache Spark,Grégory M Essertel; Ruby Y Tahboub; James M Decker; Kevin J Brown; Kunle Olukotun; Tiark Rompf,Abstract: The need for modern data analytics to combine relational; procedural; and map-reduce-style functional processing is widely recognized. State-of-the-art systems like Sparkhave added SQL front-ends and relational query optimization; which promise an increase inexpressiveness and performance. But how good are these extensions at extracting highperformance from modern hardware platforms? While Spark has made impressive progress;we show that for relational workloads; there is still a significant gap compared with best-of-breed query engines. And when stepping outside of the relational world; query optimizationtechniques are ineffective if large parts of a computation have to be treated as user-definedfunctions (UDFs).,arXiv preprint arXiv:1703.08219,2017,6
Gentrification Gone too Far? Affordable 2nd-Class Values for Fun and (Co-) Effect,Leo Osvald; Grégory Essertel; Xilun Wu; Lilliam I Gonzales Alayon; Tiark Rompf,Abstract First-class functions dramatically increase expressiveness; at the expense of staticguarantees. In ALGOL or PASCAL; functions could be passed as arguments but neverescape their defining scope. Therefore; function arguments could serve as temporary accesstokens or capabilities; enabling callees to perform some action; but only for the duration ofthe call. In modern languages; such programming patterns are no longer available. Thecentral thrust of this paper is to re-introduce second-class functions and other valuesalongside first-class entities in modern languages. We formalize second-class values withstack-bounded lifetimes as an extension to simply-typed Î» calculus; and for richer typesystems such as F<: and systems with path-dependent types. We generalize the binary first-vs second-class distinction to arbitrary privilege lattices; with the underlying type lattice as …,OOPSLA 2016,2016,5
Abstracting vector architectures in library generators: Case study convolution filters,Alen Stojanov; Georg Ofenbeck; Tiark Rompf; Markus Püschel,Abstract We present FGen; a program generator for high performance convolutionoperations (finite-impulse-response filters). The generator uses an internal mathematicalDSL to enable structural optimization at a high level of abstraction. We use FGen as atestbed to demonstrate how to provide modular and extensible support for modern SIMDvector architectures in a DSL-based generator. Specifically; we show how to combinestaging and generic programming with type classes to abstract over both the data type (realor complex) and the target architecture (eg; SSE or AVX) when mapping DSL expressions toC code with explicit vector intrinsics. Benchmarks shows that the generated code is highlycompetitive with commercial libraries.,Proceedings of ACM SIGPLAN International Workshop on Libraries; Languages; and Compilers for Array Programming,2014,5
A cryptographically t‐private auction system,Markus Hinkelmann; Andreas Jakoby; Nina Moebius; Tiark Rompf; Peer Stechert,Abstract We present a cryptographically t-private protocol for electronic auctions whose lowresource demands make it viable for practical use. Our construction is based on Yao'sgarbled circuits and pseudorandom number generators (PRNGs). Our protocol involves afield of (t+ 1) 2 parties for the generation of the garbled circuit and permits an arbitrary largenumber of bidders. The computational requirements are low: Only t+ 1 parties of the fieldhave to use the PRNG; the remaining parties execute only primitive computations (XOR;permutations and sharing). The bidders have to stay active for one round of communication;independent of each other. Each bidder has to compute only t+ 1 XOR-operations. Wepresent an implementation and evaluate its performance. The observed running time of ourprotocol is linear in the size of the auction circuit and the number of bidders and; as …,Concurrency and Computation: Practice and Experience,2011,5
Optimizing data structures in high-level programs: New directions for extensible compilers based on staging,Tiark Rompf; Arvind Sujeeth; Nada Amin; Kevin Brown; Vojin Jovanovic; H Lee; Manohar Jonnalagedda; Kunle Olukotun; Martin Odersky,Page 1. Optimizing Data Structures in High-Level Programs: New Directions for ExtensibleCompilers based on Staging Tiark Rompf; Arvind K. Sujeeth; Nada Amin; Kevin J. Brown; VojinJovanovic; HyoukJoong Lee; Manohar Jonnalagedda; Kunle Olukotun; Martin Odersky Page2. How should we build compilers? Page 3. Page 4. Programs and Languages HardwareProductivity: Generalization; Abstraction Performance: Specialization; Concretization Page 5.A Linear Algebra Library abstract class Vector[T:Numeric] { val data: Array[T] def +(that:Vector[T]) = Vector.fromArray(data.zipWith(that.data)(_ + _)) } object Vector { deffromArray[T:Numeric](a: Array[T]) = new Vector { val data = a } def zeros[T:Numeric](n: Int) =Vector.fromArray(Array.fill(n)(i => zero[T])) } abstract class Matrix[T:Numeric] { … } case classComplex(re: Double; im: Double) { def +(that: Complex) = Complex(re + that.re; im + that.im) …,Proceedings of the 40th Symposium on Principles of Programming Languages (POPL’13),2012,4
Reflections on LMS: exploring front-end alternatives,Tiark Rompf,Abstract Metaprogramming techniques to generate code at runtime in a general-purposemeta-language have seen a surge of interest in recent years; driven by the wideningperformance gap between high-level languages and emerging hardware platforms. In thecontext of Scala; the LMS (Lightweight Modular Staging) framework has contributedto``abstraction without regret''--high-level programming without performance penalty--in anumber of challenging domains; through runtime code generation and embedded compilerpipelines based on stacks of DSLs. Based on this experience; this paper crystallizes some ofthe design decisions of LMS and discusses potential alternatives; which maintain theunderlying spirit but differ in implementation choices: specifically; strategies for realizingmore flexible front-end embeddings using type classes instead of higher-kinded types …,Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala,2016,3
LMS-Verify: Abstraction Without Regret for Verified Systems Programming,Nada Amin; Tiark Rompf,Abstract Performance critical software is almost always developed in C; as programmers donot trust high-level languages to deliver the same reliable performance. This is bad becauselow-level code in unsafe languages attracts security vulnerabilities and becausedevelopment is far less productive; with PL advances mostly lost on programmers operatingunder tight performance constraints. High-level languages provide memory safety out of thebox; but they are deemed too slow and unpredictable for serious system software. Recentyears have seen a surge in staging and generative programming: the key idea is to use high-level languages and their abstraction power as glorified macro systems to compose codefragments in first-order; potentially domain-specific; intermediate languages; from which fastC can be emitted. But what about security? Since the end result is still C code; the safety …,*,2016,3
Abstraction without regret for efficient data processing,Tiark Rompf; Nada Amin; Thierry Coppey; Mohammad Dashti; Manohar Jonnalagedda; Yannis Klonatos; Martin Odersky; Christoph Koch,*,Data-Centric Programming Workshop,2014,3
What are the Odds?: probabilistic programming in Scala,Sandro Stucki; Nada Amin; Manohar Jonnalagedda; Tiark Rompf,Abstract Probabilistic programming is a powerful high-level paradigm for probabilisticmodeling and inference. We present Odds; a small domain-specific language (DSL) forprobabilistic programming; embedded in Scala. Odds provides first-class support for randomvariables and probabilistic choice; while reusing Scala's abstraction and modularity facilitiesfor composing probabilistic computations and for executing deterministic program parts.Odds accurately represents possibly dependent random variables using a probabilitymonad that models committed choice. This monadic representation of probabilistic modelscan be combined with a range of inference procedures. We present engines for exactinference; rejection sampling and importance sampling with look-ahead; but other types ofsolvers are conceivable as well. We evaluate Odds on several non-trivial probabilistic …,Proceedings of the 4th Workshop on Scala,2013,3
Staging for generic programming in space and time,Georg Ofenbeck; Tiark Rompf; Markus Püschel,Abstract Metaprogramming is among the most promising candidates to solve the abstractionvs performance trade-off that plagues software engineering through specialization.Metaprogramming has been used to enable low-overhead generic programming for a longtime; with C++ templates being one of the most prominent examples. But often a single; fixedpattern of specialization is not enough; and more flexibility is needed. Hence; this paperseeks to apply generic programming techniques to challenges in metaprogramming; inparticular to abstract over the execution stage of individual program expressions. We thusextend the scope of generic programming into the dimension of time. The resulting notion ofstage polymorphism enables novel abstractions in the design of program generators; whichwe develop and explore in this paper. We present one possible implementation; in Scala …,ACM SIGPLAN Notices,2017,2
On supporting compilation in spatial query engines:(Vision paper),Ruby Y Tahboub; Tiark Rompf,Abstract Today's' Big'spatial computing and analytics are largely processed in-memory. Still;evaluation in prominent spatial query engines is neither fully optimized for modern-classplatforms nor taking full advantage of compilation (ie; generating low-level query code).Query compilation has been rapidly rising inside in-memory relational databasemanagement systems (RDBMSs) achieving remarkable speedups; how can we bring similarbenefits to spatial query engines? In this research; we bring in proven ProgrammingLanguages (PL) approaches eg; partial evaluation; generative programming; etc. andleverage the power of modern hardware to extend query compilation inside spatial queryengines. We envision a fully compiled spatial query engine that is efficient and feasible toimplement in a high-level language. We describe LB2-Spatial; a prototype for a fully …,Proceedings of the 24th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems,2016,2
Lightweight modular staging (LMS): generate all the things!(keynote),Tiark Rompf,Abstract Recent years have seen a surge of interest in staging and generative programming;driven by the increasing difficulty of making high-level code run fast on modern hardware.While the mechanics of program generation are relatively well understood; we have onlybegun to understand how to develop systems in a generative way. The Lightweight ModularStaging (LMS) platform forms the core of a research agenda to make generativeprogramming more widely accessible; through powerful libraries and a growing selection ofcase studies that illuminate design patterns and crystallize best practices for high-level andeffective generative programming. This talk will reflect on the foundations of LMS; onapplications; achievements; challenges; as well as ongoing and future work.,ACM SIGPLAN Notices,2016,2
The essence of multi-stage evaluation in LMS,Tiark Rompf,Abstract Embedded domain-specific languages (DSLs) are the subject of wide-spreadinterest; and a variety of implementation techniques exist. Some of them have beeninvented; and some of them discovered. Many are based on a form of generative or multi-stage programming; where the host language program builds up DSL terms during itsevaluation. In this paper; we examine the execution model of LMS (Lightweight ModularStaging); a framework for embedded DSLs in Scala; and link it to evaluation in a two-stagelambda calculus. This clarifies the semantics of certain ad-hoc implementation choices; andprovides guidance for implementing similar multi-stage evaluation facilities in otherlanguages.,*,2016,2
Errata for building efficient query engines in a high-level language: PVLDB 7 (10): 853-864,Yannis Klonatos; Christoph Koch; Tiark Rompf; Hassan Chafi,Table 1 clarifies which optimizations are used in each evaluated flavor of LegoBase. HyPer-simulated is a configuration of the LegoBase codebase that mirrors the HyPer system asclosely as possible by just activating some of the main optimizations and deactivating others:using the push engine; with operator inlining active but data structure optimizations and datalayout transformations turned off. In addition; as noted in our paper (footnote 8); the actualHyPer system uses query plans generated by its own query optimizer while HyPer-simulateduses query plans from DBX. We use TPC-H queries and generated data at scaling factor 8 toevaluate the impact of our compilation techniques. For all evaluated systems; reported queryevaluation times only include the execution time of the query and exclude the time taken forquery optimization/compilation and loading the data into the main-memory data structures …,Proceedings of the VLDB Endowment,2014,2
Big data analytics with delite,Kevin J Brown; Arvind K Sujeeth; H Lee; Tiark Rompf; CD Sa; Martin Odersky; Kunle Olukotun,Page 1. Big Data Analytics with Delite Kevin J. Brown; Arvind K. Sujeeth; HyoukJoong Lee; TiarkRompf; Christopher De Sa; Martin Odersky; Kunle Olukotun Stanford University; EPFL Page 2.Page 3. Heterogeneous Parallel Architectures Today ∎ High performance capability ClusterMulticore CPU GPU FPGA Page 4. Heterogeneous Parallel Programming ∎ But high effort ClusterMulticore CPU GPU FPGA MPI MapReduce Threads OpenMP CUDA OpenCL Verilog VHDL Page5. Programmability Chasm Too many different programming models Cluster Multicore CPU GPUFPGA MPI MapReduce Threads OpenMP CUDA OpenCL Verilog VHDL Virtual Worlds PersonalRobotics Data Isnformatics Scientific Engineering Applications Page 6. Bridging theProgrammability Chasm Virtual Worlds Personal Robotics Data informatics Scientific EngineeringPhysics (Liszt) Data Analytics (OptiQL) Graph Alg. (Green Marl) …,*,2013,2
Packrat Parsing in Scala,Manohar Jonnalagedda; Martin Odersky; Tiark Rompf,Packrat Parsing is a technique for implementing backtracking; recursive-descent parsers;with the advantage that it guarantees unlimited lookahead and a linear parse time [2]. Usingthis technique; one can design parsers that can accept left recursive grammars [7]; therebydrastically expanding the class of grammars that can be accepted by such parsers. The goalof this project was to integrate such techniques on top of the Scala 1 parser-combinatorlibrary; with the main objective being seamless integration into the library; and retaining thesame ease of use as the original library. This report is organised in the following manner:The next section gives a brief introduction to the parser-combinator library; and how to use it.Chapter 2 introduces Packrat Parsing and a few implementation details behind it. Chapter 3describes how one could integrate direct left recursion into Packrat Parsers. Chapter 4 …,*,2009,2
Towards Strong Normalization for Dependent Object Types (DOT),Fei Wang; Tiark Rompf,Abstract The Dependent Object Types (DOT) family of calculi has been proposed as a newtheoretic foundation for Scala and similar languages; unifying functional programming;object oriented programming and ML-style module systems. Following the recent typesoundness proof for DOT; the present paper aims to establish stronger meta-theoreticproperties. The main result is a fully mechanized proof of strong normalization for D_<:; avariant of DOT that excludes recursive functions and recursive types. We further discusstechniques and challenges for adding recursive types while maintaining strongnormalization; and demonstrate that certain variants of recursive self types can be integratedsuccessfully.,LIPIcs-Leibniz International Proceedings in Informatics,2017,1
RandIR: differential testing for embedded compilers,Georg Ofenbeck; Tiark Rompf; Markus Püschel,Abstract This paper describes RandIR; a tool for differential testing of compilers usingrandom instances of a given intermediate representation (IR). RandIR assumes no fixedtarget language but instead supports extensible IR-definitions through an internal IR-independent representation of operations. This makes it particularly well suited to testembedded compilers for multi-stage programming; which is our main use case. The ideasunderlying our work; however; are more generally applicable. RandIR is able toautomatically simplify failing instances of a test; a technique commonly referred to asshrinking. This enables testing with large random IR samples; thus increasing the odds ofdetecting a buggy behavior; while still being able to simplify failing instances to human-readable code.,Proceedings of the 2016 7th ACM SIGPLAN Symposium on Scala,2016,1
Building Program Generators for High-Performance Spiral on Scala,Georg Ofenbeck; Tiark Rompf; Alen Stojanov; Martin Odersky; Markus Püschel,Abstract. The development of high performance libraries on modern hardware is extremelydi cult and often requires reimplementation or retuning with every new processor generation.Program generators that produce such libraries automatically from a high level descriptionare an appealing solution but only few exist to date. The di culty is in both the design of thegenerator but also its actual implementation; which often results in an ad-hoc collection ofstandalone programs and scripts that are hard to extend; maintain; or reuse. In this paper weask whether there is a programming language environment suitable for building suchgenerators. We argue in two steps that Scala with lightweight modular staging (LMS) is suchan environment. First; we extract from existing generators the requirements that a suitableenvironment should fulfill. The list includes elegant support for internal DSLs; DSL …,iWAPT 2014,2014,1
Mind the Gap: Artifacts vs Insights in PL Theory,Nada Amin; Tiark Rompf,A common template for papers at PL conferences is to present a calculus and prove someproperties such as soundness. How can we assess the value of such papers? In this talk; wesuggest that the most valuable formalization efforts are those which explore the designspace. Soundness results rarely compose (think let-polymorphism and mutable references);yet real systems need to combine features and make compromises. Hence; we need to mindthe gap: give implementors of practical systems not just core calculi–polished but ofquestionable applicability–but real insights into the trade-offs of the landscape. A goodexample is the work of Olivier Danvy and his collaborators on inter-derivation of semanticartifacts; which exposes deep connections between a large class of individually proposedevaluators and abstract machines. In more general terms; we argue that we should have …,POPL Off the Beaten Track (OBT) 2014,2014,1
Design and implementation of a programming language for concurrent interactive systems,Tiark Rompf,Abstract This thesis describes the design and implementation of a new experimentalprogramming language with a focus on creating concurrent; interactive systems. As such;the language makes concurrent programming the default case; providing fine-grainedconcurrency primitives at the language level and a runtime system that is geared towardsexecution on multiprocessor hardware. The language semantics are first describedoperationally; in terms of generalized Functional Petri Nets; and then refined to a model ofasynchronously interacting components. Code examples are shown that describe howadvanced object-oriented and functional programming concepts such as open genericfunctions/multimethods are a natural specialization of the core language abstractions. Otherprogramming examples draw from areas such as dataflow-oriented graphical user …,*,2007,1
SIMD intrinsics on managed language runtimes,Alen Stojanov; Ivaylo Toskov; Tiark Rompf; Markus Püschel,Abstract Managed language runtimes such as the Java Virtual Machine (JVM) provideadequate performance for a wide range of applications; but at the same time; they lack muchof the low-level control that performance-minded programmers appreciate in languageslike< pre> C/C++</pre>. One important example is the intrinsics interface that exposesinstructions of SIMD (Single Instruction Multiple Data) vector ISAs (Instruction SetArchitectures). In this paper we present an automatic approach for including native intrinsicsin the runtime of a managed language. Our implementation consists of two parts. First; foreach vector ISA; we automatically generate the intrinsics API from the vendor-provided XMLspecification. Second; we employ a metaprogramming approach that enables programmersto generate and load native code at runtime. In this setting; programmers can use the …,Proceedings of the 2018 International Symposium on Code Generation and Optimization,2018,*
From Gameplay to Symbolic Reasoning: Learning SAT Solver Heuristics in the Style of Alpha (Go) Zero,Fei Wang; Tiark Rompf,Abstract: Despite the recent successes of deep neural networks in various fields such asimage and speech recognition; natural language processing; and reinforcement learning;we still face big challenges in bringing the power of numeric optimization to symbolicreasoning. Researchers have proposed different avenues such as neural machinetranslation for proof synthesis; vectorization of symbols and expressions for representingsymbolic patterns; and coupling of neural back-ends for dimensionality reduction withsymbolic front-ends for decision making. However; these initial explorations are still onlypoint solutions; and bear other shortcomings such as lack of correctness guarantees. In thispaper; we present our approach of casting symbolic reasoning as games; and directlyharnessing the power of deep reinforcement learning in the style of Alpha (Go) Zero on …,arXiv preprint arXiv:1802.05340,2018,*
From Gameplay to Symbolic Reasoning,Fei Wang; Tiark Rompf,Abstract: Despite the recent successes of deep neural networks in various fields such asimage and speech recognition; natural language processing; and reinforcement learning;we still face big challenges bringing the power of numeric optimization to symbolicreasoning. Researchers have proposed different avenues such as neural machinetranslation for proof synthesis; vectorization of symbols and expressions for representingsymbolic patterns; and coupling of neural back-ends for dimensionality reduction withsymbolic front-ends for decision making. However; these initial explorations are still onlypoint solutions; and bear other shortcomings such as lack of correctness guarantees. In thispaper; we present our approach of casting symbolic reasoning as games; and directlyharnessing the power of deep reinforcement learning in the style of Alpha (Go) Zero on …,*,2018,*
A Language and Compiler View on Differentiable Programming,Fei Wang; Tiark Rompf,Abstract: Current and emerging deep learning architectures call for an expressive high-levelprogramming style with end-to-end differentiation and for a high-performanceimplementation at the same time. But the current generation of deep learning frameworkseither limits expressiveness and ease of use for increased performance (eg; TensorFlow) orvice versa (eg; PyTorch). In this paper we demonstrate that a “best of both worlds” approachis possible; based on multi-stage programming and delimited continuations; two orthogonalideas firmly rooted in programming languages research.,*,2018,*
Rust-like borrowing with 2nd-class values (short paper),Leo Osvald; Tiark Rompf,Abstract The Rust programming language demonstrates that memory safety can beachieved in a practical systems language; based on a sophisticated type system thatcontrols object lifetimes and aliasing through notions of ownership and borrowing. WhileScala has traditionally targeted only managed language runtimes; the ScalaNative effortmakes Scala a viable low-level language as well. Thus; memory safety becomes animportant concern; and the question bears asking what; if anything; Scala can learn fromRust. In addition; Rust's type system can encode forms of protocols; state machines; andsession types; which would also be useful for Scala in general. A key challenge is that Rust'styping rules are inherently flow-sensitive; but Scala's type system is not. In this paper; wesketch one possible method of achieving static guarantees similar to Rust with only mild …,Proceedings of the 8th ACM SIGPLAN International Symposium on Scala,2017,*
Flexible data views: design and implementation,Leo Osvald; Tiark Rompf,Abstract In this paper; we present a library-based framework of data views over chunks ofmemory segments. Such views not only enable a uniform treatment of references andarrays; but they provide a more general abstraction in the sense that parts of arrays;references; or even views; can be combined into hierarchies to form new logical datastructures. To provide efficient implementations in widely used industrial languages such asC++ and Scala; we employ static and dynamic multi-staging techniques; respectively.Through staging and code specialization; the overhead of traversal and tracking of suchview hierarchies is mostly eliminated. Thus; our data views can be used as building blocksfor creating data structures for which programmers need not pick a specific representationbut can rely on code generation and specialization to provide the right implementation …,Proceedings of the 4th ACM SIGPLAN International Workshop on Libraries; Languages; and Compilers for Array Programming,2017,*
Composing middlebox and traffic engineering policies in SDNs,Yiyang Chang; Gustavo Petri; Sanjay Rao; Tiark Rompf,Middleboxes present new requirements that need to be integrated with traffic engineeringapplications that are already complex and consider myriad factors (eg; routing; QoS; load-balancing). While it is possible to revisit traffic engineering algorithms to explicitly integratemiddleboxes; such an approach is not compositional. Existing efforts at compositional SDNapplication development do not apply since they support application composition after staticpacket-forwarding policies are generated by application modules. Consequently; routescomputed by a traffic engineering module cannot be influenced by the constraints imposedby a module that specifies middlebox traversal requirements. In this paper; we explore analternate approach where application composition is done prior to the generation of packet-forwarding policies. Each application is written as a logic program; and provides a set of …,Computer Communications Workshops (INFOCOM WKSHPS); 2017 IEEE Conference on,2017,*
Functional parallels of sequential imperatives (short paper),Tiark Rompf; Kevin J Brown,Abstract Symbolic parallelism is a fresh look at the decade-old problem of turningsequential; imperative; code into associative reduction kernels; based on the realization thatmap/reduce is at its core a staging problem: how can programs be separated so that part ofthe computation can be done before loop-carried dependencies become available?Previous work has investigated dynamic approaches that build symbolic summaries whilethe actual data is processed. In this short paper; we approach the problem from the staticside; and show that with simple syntax-or type-driven transformations; we can readilytransform large classes of imperative groupby-aggregate programs into map/reduceparallelism with deterministic overhead.,Proceedings of the 2017 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation,2017,*
Towards Strong Normalization for Dependent Object Types (DOT)(Artifact),Fei Wang; Tiark Rompf,Abstract This artifact provides the fully mechanized proof of strong normalization for D_ {<:};a variant of (Dependent Object Types) DOT (Rompf & Amin; 2016) that excludes recursivefunctions and recursive types. The intersection type and recursive self type are furtherintegrated; moving towards DOT. The key proof idea follows the method of Girard (Girard;1972) and Tait (Tait; 1967).,DARTS-Dagstuhl Artifacts Series,2017,*
Collapsing Towers of Interpreters,Nada Amin; Tiark Rompf,Abstract Given a tower of interpreters; ie; a sequence of multiple interpreters interpreting oneanother as input programs; we aim to collapse this tower into a compiler that removes allinterpretive overhead and runs in a single pass. In the real world; a use case might bePython code executed by an x86 runtime; on a CPU emulated in a JavaScript VM; runningon an ARM CPU. Collapsing such a tower can not only exponentially improve runtimeperformance; but also enable the use of base-language tools for interpreted programs; eg;for analysis and verification. In this paper; we lay the foundations in an idealized but realisticsetting. We present a multi-level lambda calculus that features staging constructs and stagepolymorphism: based on runtime parameters; an evaluator either executes source code(thereby acting as an interpreter) or generates code (thereby acting as a compiler). We …,*,2016,*
Abstraction Without Regret in Database Systems Building: a Manifesto,Yanif Ahmad; Hassan Chafi; Thierry Coppey; Mohammad Dashti; Vojin Jovanovic; Oliver Kennedy; Yannis Klonatos; Milos Nikolic; Andres Noetzli; Martin Odersky; Tiark Rompf; Amir Shaikhha,Abstract It has been said that all problems in computer science can be solved by addinganother level of indirection; except for performance problems; which are solved by removinglevels of indirection. Compilers are our tools for removing levels of indirection automatically.However; we do not trust them when it comes to systems building. Most performance-criticalsystems are built in low-level programming languages such as C. Some of the downsides ofthis compared to using modern high-level programming languages are very well known:bugs; poor programmer productivity; a talent bottleneck; and cruelty to programminglanguage researchers. In the future we might even add suboptimal performance to this list. Inthis article; I argue that compilers can be competitive with and outperform human experts atlow-level database systems programming. Performance-critical database systems are a …,*,2014,*
Language support for the construction of high performance code generators,Georg Ofenbeck; Tiark Rompf; Alen Stojanov; Martin Odersky; Markus Püschel,*,ADAPT 2014,2014,*
Tool Demo: Scala-Virtualized,Adriaan Moors; Tiark Rompf; Philipp Haller; Martin Odersky,*,PEPM 2012,2012,*
The magazine archive includes every article published in Communications of the ACM for over the past 50 years.,Martin Odersky; Tiark Rompf,Though IT originated as an academic research project; Scala has seen rapid disseminationin industry and open source software development. Here; we give a high-level introductionto Scala and look to explain what makes it appealing for developers. The conceptualdevelopment of Scala began in 2001 at École polytechnique fédérale de Lausanne (EPFL)in Switzerland. The first internal version of the language appeared in 2003 when it was alsotaught in an undergraduate course on functional programming. The first public release wasin 2004; and the 2. x series in 2006; with slightly redesigned language and a new compiler;written completely in Scala itself. Shortly thereafter; an ecosystem of open-source softwarebegan to form around it; with the Lift Web framework as an early crystallization point. Scalaalso began to be used in industry. A well-known adoption was Twitter; which aimed (in …,Communications of the ACM,*,*
Functional Parallels of Sequential Imperatives,Tiark Rompf; Kevin J Brown,*,*,*,*
About Authors,Tiark Rompf,Page 1. Lightweight Modular Staging: A Pragmatic Approach to Runtime Code Generation andCompiled DSLs Tiark Rompf; Martin Odersky École Polytechnique Fédérale de Lausanne (EPFL)Page 2. About Authors: Tiark Rompf • Received an MS in computer science from University ofLübeck (2008) and a PhD from EPFL (2012). • A member of Martin Odersky's Scala team since2008. • Is joining Purdue University as assistant professor in fall 2014. • Contributions: • Scala(delimited continuations; efficient immutable data structures; speedup in compiler);Scala-Virtualized; LMS; Delite… Page 3. About Authors: Martin Odersky • Professor ofprogramming methods at EPFL. • Received Ph.D. from ETH Zurich under the supervision ofNiklaus Wirth (the creator of Pascal). • Founder; chairman; and chief architect of Typesafe Inc. •Creates Scala. Page 4. Short Description • An implementation of multi-stage programing in …,*,*,*
